[{"path":"https://ms609.github.io/TreeSearch/dev/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (https://www.contributor-covenant.org), version 1.0.0, available https://contributor-covenant.org/version/1/0/0/.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"CONTRIBUTING","text":"Small typos grammatical errors documentation may edited directly using GitHub web interface, long changes made source file. YES: edit roxygen comment .R file R/. : edit .Rd file man/.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/CONTRIBUTING.html","id":"prerequisites","dir":"","previous_headings":"","what":"Prerequisites","title":"CONTRIBUTING","text":"make substantial pull request, always file issue make sure someone team agrees ’s problem. ’ve found bug, create associated issue illustrate bug minimal reprex.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"","what":"Pull request process","title":"CONTRIBUTING","text":"recommend create Git branch pull request (PR). Look GitHub actions build status making changes. follow Google’s R style guide use camelCase variable names, TitleCase function names. use Oxford ending ‘ize’ (‘ise’), UK spelling (e.g. ‘colour’) possible avoid distinction (e.g. shortening ‘col’) use roxygen2. use testthat. Contributions test cases included easier accept. use semantic versioning. user-facing changes, add bullet top NEWS.md current development version header describing changes made followed GitHub username, links relevant issue(s)/PR(s).","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/CONTRIBUTING.html","id":"contributor-license-agreement","dir":"","previous_headings":"","what":"Contributor license agreement","title":"CONTRIBUTING","text":"Contributors agree reassign copyright contributions maintainers package.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"CONTRIBUTING","text":"Please note project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/CONTRIBUTING.html","id":"prefer-to-email","dir":"","previous_headings":"","what":"Prefer to Email?","title":"CONTRIBUTING","text":"Email person listed maintainer DESCRIPTION file repo. Though note private discussions email don’t help others - course email totally warranted ’s sensitive problem kind.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/CONTRIBUTING.html","id":"thanks-for-contributing","dir":"","previous_headings":"","what":"Thanks for contributing!","title":"CONTRIBUTING","text":"contributing guide adapted tidyverse contributing guide available https://raw.githubusercontent.com/r-lib/usethis/master/inst/templates/tidy-contributing.md","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/custom.html","id":"using-custom-optimality-criteria","dir":"Articles","previous_headings":"","what":"Using custom optimality criteria","title":"Tree search with custom optimality criteria","text":"“TreeSearch” can used search trees optimal user-specified criteria (e.g. Hopkins & St. John, 2021). needed provide function return score given tree (dataset). First ’ll load necessary R libraries:","code":"library(\"TreeTools\", quietly = TRUE, warn.conflict = FALSE) library(\"TreeSearch\")  # Plot trees nicely PlotTree <- function(tree, ...) {   oPar <- par(mar = rep(0, 4), cex = 0.9)   plot(tree)   par(oPar) }"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/custom.html","id":"maximizing-tree-balance","dir":"Articles","previous_headings":"","what":"Maximizing tree balance","title":"Tree search with custom optimality criteria","text":"’ll start simple case: aiming minimise total cophenetic index [TIC; Mir, Rosselló, & Rotger (2013)] tree. TCI measure tree balance; depend input dataset. need write TreeScorer function. function sent parent child nodes edge tree, (, empty) dataset parameter. function return score minimized. , can use copy starting tree template, populated rearranged parent child vectors:  Now can use scorer tree search. need initialize parameters TreeSearch() null values: dataset = EmptyPhyDat(tree) sends blank dataset (tree scorer doesn’t require data); set InitializeData = DoNothing CleanUpData = DoNothing don’t need anything dataset sent TreeScorer().","code":"tree <- PectinateTree(8) PlotTree(tree) TCIScore <- function(parent, child, dataset) {   tree$edge <- cbind(parent, child)   TotalCopheneticIndex(tree) }  TCIScore(tree$edge[, 1], tree$edge[, 2], NA) ## [1] 56 result <- TreeSearch(tree, dataset = EmptyPhyDat(tree),                      InitializeData = DoNothing, CleanUpData = DoNothing,                      TreeScorer = TCIScore,                      maxIter = 50L, maxHits = 10L,                       verbosity = 1L) ##   - Performing tree search.  Initial score: 56 ##   - Final score 33 found 5 times after 50 rearrangements. PlotTree(result)"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/custom.html","id":"maximizing-tree-distance","dir":"Articles","previous_headings":"","what":"Maximizing tree distance","title":"Tree search with custom optimality criteria","text":"Let’s make things slightly complex, try find tree different starting tree. Notice TreeSearch aims minimize output TreeScorer(), negate tree distance (aim maximize) returning .","code":"startTree <- BalancedTree(8)  DistanceScore <- function(parent, child, dataset) {   tmpTree <- startTree   tmpTree$edge <- cbind(parent, child)   distance <- TreeDist::ClusteringInfoDistance(startTree, tmpTree)   # Return:   -distance }  result <- TreeSearch(RandomTree(8, root = TRUE), dataset = EmptyPhyDat(tree),                      InitializeData = DoNothing, CleanUpData = DoNothing,                      TreeScorer = DistanceScore,                      maxIter = 50L, maxHits = 10L,                       verbosity = 1L) ##   - Performing tree search.  Initial score: -5.77985386969094 ##   - Final score -7.5661656266226 found 3 times after 50 rearrangements. par(mfrow = c(1, 2)) PlotTree(startTree) PlotTree(result)"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/custom.html","id":"searching-using-implied-weights","dir":"Articles","previous_headings":"","what":"Searching using implied weights","title":"Tree search with custom optimality criteria","text":"Now consider complex case scorer must undergo time-consuming initialization tree search can begin, must safely destroyed tree search completed. start defining initialization function, create new Morphy object (Brazeau, Smith, & Guillerme, 2017) character phylogenetic dataset: release memory back operating system, must destroy Morphy object ’re finished : Now can write tree scoring function, return ‘fit’ implied weights (Goloboff, 1993). Note need specify extra parameters: concavity k value required implied weights formula (fit = e / e + k), minLength minimum number steps required character – need order convert total number steps (returned MorphyLength() number excess steps (e implied weights formula) Now ready search: quick search probably hasn’t found globally optimal tree. Besides increasing number hits rearrangements, parsimony ratchet (Nixon, 1999) can help escape local optima. introduces additional complication: need bootstrap characters within dataset, accompanying Morphy objects. Bootstraper function expects edgeList (list parent child edge tree, turn) dataset argument, conducts tree search, starting edgeList, bootstrapped version dataset. also sent arguments maxIter = bootstrapIter maxHits = bootstrapHits, allowing ratchet search intensity controlled parameters sent Ratchet() function. defined Bootstrapper() function can now complete Ratchet search : sensible use much larger values ratchIter, ratchHits, searchIter searchHits confident locating optimal tree. note specific case, implied weights tree search parsimony ratchet implemented much efficiently MaximizeParsimony(concavity = k). Hopefully examples give template able construct optimality criteria. maintainer happy answer questions via e-mail, can file queries opening GitHub issue.","code":"IWInitMorphy <- function (dataset) {   attr(dataset, \"morphyObjs\") <-      lapply(PhyToString(dataset, byTaxon = FALSE, useIndex = FALSE,                         concatenate = FALSE),             SingleCharMorphy)      # Return:   dataset } IWDestroyMorphy <- function (dataset) {   vapply(attr(dataset, \"morphyObjs\"), UnloadMorphy, integer(1)) } IWScoreMorphy <- function (parent, child, dataset, concavity = 10L,                             minLength = attr(dataset, \"min.length\"), ...) {   steps <- vapply(attr(dataset, \"morphyObjs\"), MorphyLength,                   parent = parent, child = child, integer(1))   homoplasies <- steps - minLength   fit <- homoplasies / (homoplasies + concavity)   # Return:   sum(fit * attr(dataset, \"weight\")) } data(\"inapplicable.datasets\") dataset <- congreveLamsdellMatrices[[42]]  # Populate `min.length` attribute dataset <- PrepareDataIW(dataset) iwTree <- TreeSearch(NJTree(dataset), dataset,                      InitializeData = IWInitMorphy,                      CleanUpData = IWDestroyMorphy,                      TreeScorer = IWScoreMorphy,                      concavity = 10, # Will be sent to TreeScorer                      verbosity = 1) IWBootstrap <- function (edgeList, dataset, concavity = 10L, EdgeSwapper = NNISwap,                           maxIter, maxHits, verbosity = 1L, ...) {   att <- attributes(dataset)   startWeights <- att[[\"weight\"]]      # Decompress phyDat object so each character is listed once   eachChar <- seq_along(startWeights)   deindexedChars <- rep.int(eachChar, startWeights)      # Resample characters   resampling <- tabulate(sample(deindexedChars, replace = TRUE), length(startWeights))   sampled <- resampling != 0   sampledData <- lapply(dataset, function (x) x[sampled])   sampledAtt <- att   sampledAtt[[\"weight\"]] <- resampling[sampled]   sampledAtt[[\"index\"]] <- rep.int(seq_len(sum(sampled)), resampling[sampled])   sampledAtt[[\"min.length\"]] <- minLength <- att[[\"min.length\"]][sampled]   sampledAtt[[\"morphyObjs\"]] <- att[[\"morphyObjs\"]][sampled]   attributes(sampledData) <- sampledAtt      # Search using resampled dataset   res <- EdgeListSearch(edgeList[1:2], sampledData, TreeScorer = IWScoreMorphy,                         concavity = concavity, minLength = minLength,                         EdgeSwapper = EdgeSwapper,                          maxIter = maxIter, maxHits = maxHits,                         verbosity = verbosity - 1L)      res[1:2] } ratchetTree <- Ratchet(tree = iwTree, dataset = dataset,                        concavity = 10,                        InitializeData = IWInitMorphy,                         CleanUpData = IWDestroyMorphy,                        TreeScorer = IWScoreMorphy,                        Bootstrapper = IWBootstrap,                        ratchIter = 2, ratchHits = 2,                        searchIter = 20, searchHits = 10,                        verbosity = 2)"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/custom.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Tree search with custom optimality criteria","text":"might want : Load data Nexus file spreadsheet Conduct parsimony search using Brazeau, Guillerme & Smith’s approach inapplicable data, using Profile parsimony. See also: Guide installation Documentation home Mapping space optimal trees","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/articles/getting-started.html","id":"simple-installation","dir":"Articles","previous_headings":"Installation","what":"Simple installation","title":"Getting started: Installing R and TreeSearch","text":"use “TreeSearch” first need install R. RStudio popular front-end makes several R’s features easier use. “TreeSearch” package can installed package. get latest stable version CRAN, type R (RStudio) command line. installed, load “TreeSearch” package R using Activate graphical user interface typing EasyTrees(). Jan 2022, users reporting issues loading trees Nexus files. arise due issue underlying “ape” package. install patched version, close re-launch R run: Windows users may need install Rtools installing GitHub source.","code":"install.packages(\"TreeSearch\") library(\"TreeSearch\") if (!require(\"remotes\")) install.packages(\"remotes\") remotes::install_github(\"ms609/ape@patch-3\")"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/getting-started.html","id":"for-advanced-users","dir":"Articles","previous_headings":"Installation","what":"For advanced users","title":"Getting started: Installing R and TreeSearch","text":"get latest development version GitHub, type","code":"remotes::install_github(\"ms609/TreeSearch\")"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/getting-started.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Getting started: Installing R and TreeSearch","text":"might want : Load data Nexus file spreadsheet Conduct parsimony search using Brazeau, Guillerme & Smith’s approach inapplicable data, using Profile parsimony. Conduct parsimony search using custom optimality criteria.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile-scores.html","id":"scope-of-this-document","dir":"Articles","previous_headings":"","what":"Scope of this document","title":"Profile parsimony","text":"document aims give flavour justification using parsimony general, profile parsimony particular, reconstruct evolutionary history; summarize mathematical/information theoretic underpinning profile parsimony approach. ’ll open acknowledging philosophical approach everyone’s cup tea – ’s certainly home turf. tend prefer models can shown work well, without worrying much abstract philosophy – though admittedly, identifying ‘best’ method always straightforward (e.g. Smith, 2019). also acknowledge practical considerations can influence choice reconstruction method: tip-dated phylogeny accomplished parsimony framework, example; principled model evolutionary change available, certain subsets molecular data, see compelling case using models infer phylogeny. goal argue method superior, develop case profile parsimony rests principled underpinning – , prove outperform methods certain circumstances, give sense might .","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile-scores.html","id":"a-philosophy-of-parsimony","dir":"Articles","previous_headings":"","what":"A philosophy of parsimony","title":"Profile parsimony","text":"number complementary perspectives philosophical justification parsimony approach (e.g. Farris, 1983), brief overview justice ; hopefully unqualified largely unreferenced perspective captures nature principal arguments. Better-versed readers invited suggest improvements modifications e-mail opening GitHub issue. Parsimony defended reference Occam’s Razor: principle scientists prefer simplest explanation can provide adequate account observed data. context morphological phylogenetics, “observed data” codified observed character states scored within matrix. Ideally, phylogenetic tree explain distribution character states taxa reconstructing character state representing homologous feature, single evolutionary origin tree. explanation certain trait evolved simpler one trait evolved twice; less faithful information inherent character coding, attributes less information common ancestry. additional step tree can viewed additional “assumption”, simple “pure” view, tree makes fewest assumptions preferred. However, perspective – implicitly underpins practice equal-weights parsimony – treats assumptions equivalent; simplest hypothesis one makes fewest assumptions (, assumptions homoplasy). nuanced interpretation Occam’s Razor suggests simplest hypothesis one least surprising. hypothesis predicated existence flying spaghetti monster may require single (barmy) assumption, might nevertheless tend prefer hypothesis requires greater number assumptions better aligned previous experience.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile-scores.html","id":"application-of-occams-razor","dir":"Articles","previous_headings":"A philosophy of parsimony","what":"Application of Occam’s Razor","title":"Profile parsimony","text":"interpretation two applications phylogenetics. first may wish prefer trees (depictions phylogenetic hypotheses) concentrate homoplasy characters believe prone convergent evolution. view calls character weighting, , assigning less weight changes characters believed less phylogenetically reliable. characters may identified successive approximations (Farris, 1969), comparing pattern tokens characters, expert judgement, priori means. second application argues additional case homoplasy beyond first successively less surprising: first observation homoplasy (rather prior intuition) taught us character entirely reliable, making second homoplasy less unexpected; second observed homoplasy, turn, makes us less surprised third. approach calls step weighting approach, additional step given character receives less penalty last. (Mathematically, can expressed character weighting strategy; feel posteriori nature conveys subtly different motivation justifies separate treatment.) raises question step beyond first penalized. Ultimately, concave function (step penalized positive amount smaller penalty applied previous step) consistent philosophy (Arias & Miranda-Esquivel, 2004). widely used step weighting approach Goloboff’s (1993) implied weighting, total cost associated character expressed e / (e + k), e number homoplasies within character, k arbitrary constant. e tends infinity, approach tends equal weights; k tends zero, tends clique analysis (character either homologous ignored) (Farris, 1983). appropriate value k may depend number taxa, number distribution observed states, factors (Goloboff, Carpenter, Arias, & Esquivel, 2008; Goloboff, Torres, & Arias, 2018) (detailed treatment provided revision document). Moreover, adjustment must made ‘missing’ data, .e. ambiguous tokens, reduce opportunity observe homoplasy (Goloboff, 2014). Implied weighting described approximation (Goloboff, 1993), aware straightforward interpretation ‘fit’ score, principled definition nature quantity approximated.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile-scores.html","id":"an-information-theoretic-basis","dir":"Articles","previous_headings":"A philosophy of parsimony","what":"An information theoretic basis","title":"Profile parsimony","text":"argue quantity seek minimise “surprise” tree. Information theory science quantifying unexpectedness. Information usually measured bits. One bit amount information generated tossing fair coin: record outcome coin toss, must record either H T, two symbols equally likely, way compress results multiple tosses. Shannon (1948) information content outcome xx defined h(x)=−log2P(x)h(x) = -\\log_2{P(x)}, simplifies log2n\\log_2{n} nn outcomes equally likely. Thus, outcome fair coin toss delivers log22=1 bit\\log_2{2} = 1\\textrm{ bit} information; outcome rolling fair six-sided die contains log26≈2.58 bits\\log_2{6} \\approx 2.58\\textrm{ bits} information; outcome selecting random one 105 unrooted binary six-leaf trees log2105≈6.71 bits\\log_2{105} \\approx 6.71\\textrm{ bits}. Unlikely outcomes surprising, thus contain information likely outcomes. information content rolling twelve two fair six-sided dice −log2136≈5.16 bits-\\log_2{\\frac{1}{36}} \\approx 5.16\\textrm{ bits}, whereas seven, produced six 36 possible rolls (1 & 6, 2 & 5, …), less surprising, thus contains less information: −log2636≈2.58 bits-\\log_2{\\frac{6}{36}} \\approx 2.58\\textrm{ bits}. additional 2.58 bits information required establish whether rolls 1 & 6, 2 & 5, … occurred. Now consider two competing explanations event: (), three consecutive rolls two dice produced seven; (ii), two consecutive rolls two dice produced twelve. former event corresponds 3×2.58=7.75 bits3 \\times 2.58 = 7.75\\textrm{ bits} information, less surprising latter, represents 2×5.16=10.34 bits2 \\times 5.16 = 10.34\\textrm{ bits}, despite involving additional roll dice. measure “surprise” associated additional steps character phylogenetic tree? Consider character states 0 0 0 1 1 1. parsimonious situation character contains single step tree, compatible nine 105 labelled six-leaf trees, thus represents −log29105=3.54 bits-log_2\\frac{9}{105} = 3.54\\textrm{ bits} phylogenetic information. told character contains exactly two steps, can occur 63 trees, yields −log263105=0.74 bits-log_2\\frac{63}{105} = 0.74\\textrm{ bits}. (number trees m extra steps can calculated using theorem 1 Carter, Hendy, Penny, Székely, & Wormald (1990), implemented function Carter1().) Learning second step occurred meant 3.54 − 0.74 = 2.81 bits information previously attributed common ancestry instead represent signature homoplasy; quantity measures degree ‘surprise’. subsequently learn character contains three steps, can occur six-leaf tree, contains phylogenetic information. less surprised third step, attributes remaining 0.74 bits information factors common ancestry, second step already reduced amount phylogenetic information expected character hold.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile-scores.html","id":"profile-parsimony","dir":"Articles","previous_headings":"","what":"Profile parsimony","title":"Profile parsimony","text":"Although approach initially justified (Faith & Trueman, 2001), profile parsimony aims ascribe much information character possible common ancestry; example , assigns first extra step penalty 2.81, second extra step penalty 0.74, corresponding amount information longer assigned common ancestry learning existence nnth step. Whereas value parsimony score obtained implied weights inherent meaning, profile parsimony score given tree represents amount information within character matrix can attributed common ancestry tree, , expressed proportion total cladistic information content characters matrix (Cotton & Wilkinson, 2008), gives indication degree homoplasy underlying character matrix. Profile parsimony produces concavity profile reflects opportunity observe additional steps character, unlike implied weighting, single concavity value applied characters, regardless opportunity additional steps observed.  graph shows profiles implied weighting (different concavity constants) profile parsimony (different distributions tokens 0 1 character coded forty leaves). One prominent difference character concavity profiles implied weighting continues assign relatively large penalties additional steps even distribution character almost random tree. Another profile parsimony treats second (subsequent) step less surprising fewer opportunities observe second step chance, account smaller number tokens rarer step; implied weighting blind distribution tokens within character.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile-scores.html","id":"implementation","dir":"Articles","previous_headings":"","what":"Implementation","title":"Profile parsimony","text":"present implementation profile parsimony “TreeSearch” restricted: inapplicable tokens treated ambiguous; partial ambiguity (e.g. {02}) treated complete (?), informative states (.e. states present one taxon) beyond first two ignored (treated ambiguous). reflects complicated mathematics calculating number trees given number steps. Tree length can calculated TreeLength(concavity = \"profile\"), tree search performed MaximizeParsimony(concavity = \"profile\"). Data can prepared profile parsimony using PrepareDataProfile(), profile character calculated using StepInformation().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile-scores.html","id":"where-next","dir":"Articles","previous_headings":"","what":"Where next","title":"Profile parsimony","text":"Conduct tree search using profile parsimony See also: Guide installation Documentation home","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Tree search with Profile parsimony","text":"companion vignette gives details installing package getting running. installed, load inapplicable package R using order reproduce random elements document, set random seed:","code":"library(\"TreeSearch\") # Set a random seed so that random functions in this document are reproducible RNGversion(\"3.5.0\") ## Warning in RNGkind(\"Mersenne-Twister\", \"Inversion\", \"Rounding\"): non-uniform ## 'Rounding' sampler used set.seed(888)"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile.html","id":"scoring-a-tree-and-conducting-a-tree-search","dir":"Articles","previous_headings":"","what":"Scoring a tree, and conducting a tree search","title":"Tree search with Profile parsimony","text":"’s example using package conduct tree search profile parsimony. can load dataset, example, ’ll use simulated dataset comes bundled TreeSearch package. Unless starting tree provided, tree search random addition tree:  alternatively use random neighbour-joining tree: search trees better score using TBR rearrangements parsimony ratchet (Nixon, 1999): ’ve used low values ratchIter, tbrIter maxHits rapid run, necessarily thorough enough search find globally optimal tree. Nevertheless, let’s see resultant tree, score:  default parameters may enough find optimal tree; type ?MaximizeParsimony view search parameters – keep repeating search tree score stops improving.","code":"data(congreveLamsdellMatrices) myMatrix <- congreveLamsdellMatrices[[10]] additionTree <- AdditionTree(myMatrix, concavity = \"profile\") TreeLength(additionTree, myMatrix, \"profile\") ## [1] 552.6187 par(mar = rep(0.25, 4), cex = 0.75) # make plot easier to read plot(additionTree) randomTree <- TreeTools::RandomTree(myMatrix, root = TRUE) TreeLength(randomTree, myMatrix, \"profile\") ## [1] 783.324 njTree <- TreeTools::NJTree(myMatrix) TreeLength(njTree, myMatrix, \"profile\") ## [1] 540.2259 betterTrees <- MaximizeParsimony(myMatrix, additionTree, concavity = \"profile\",                                  ratchIter = 3, tbrIter = 3, maxHits = 8) TreeLength(betterTrees[[1]], myMatrix, \"profile\") ## [1] 512.1181 par(mar = rep(0.25, 4), cex = 0.75) # make plot easier to read plot(ape::consensus(betterTrees))"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile.html","id":"view-the-results","dir":"Articles","previous_headings":"","what":"View the results","title":"Tree search with Profile parsimony","text":"parsimony search, good practice consider trees slightly suboptimal (Smith, 2019). , ’ll take consensus includes trees suboptimal 3 bits. sample region tree space well, trick use large values ratchHits ratchIter, small values searchHits searchiter, many runs don’t quite hit optimal tree. serious study, want sample many 3 Ratchet hits (ratchHits) ’ll settle , probably using many Ratchet iterations. consensus slightly suboptimal trees provides less resolved, typically reliable, summary signal phylogenetic dataset (Smith, 2019):","code":"suboptimals <- MaximizeParsimony(myMatrix, betterTrees, tolerance = 3,                                  ratchIter = 2, tbrIter = 3,                                  maxHits = 25,                                  concavity = \"profile\") par(mar = rep(0.25, 4), cex = 0.75) table(signif(TreeLength(suboptimals, myMatrix, \"profile\"))) ##  ## 512.118 513.229 513.897 513.966 514.739 514.849  ##       2       1       1       3       1       1 plot(ape::consensus(suboptimals))"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/profile.html","id":"where-next","dir":"Articles","previous_headings":"","what":"Where next?","title":"Tree search with Profile parsimony","text":"Documentation home Guide installation Search trees using standard parsimony (corrected inapplicable data) custom optimality criteria Explore distribution optimal trees mappings","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-search.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Getting started: Simple tree searches","text":"companion vignette gives details installing package getting running. Launch interactive ‘app’ browser typing TreeSearch::EasyTrees() R / RStudio command line. allow load data file, modify search settings, explore distribution parsimonious trees tree space. View consensus tree explore position rogue taxa (Smith, 2022b): Explore distribution trees (whether found search loaded file) tree space (Smith, 2022a), evaluate search progress (Whidden & Matsen, 2015): Map characters chosen tree, using character taxon notes imported Nexus file, present. (designed interoperable MorphoBank matrices.) Trees can saved images, Nexus/Newick analysis.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-search.html","id":"command-line-tree-search","dir":"Articles","previous_headings":"","what":"Command line tree search","title":"Getting started: Simple tree searches","text":"can also run tree searches using R command line. installed, load “TreeSearch” package R using can load dataset, now, ’ll use Vinther et al. (2008) dataset comes bundled “TreeSearch”. dataset small enough runs reasonably quickly, phylogenetic signal obscure enough can require Ratchet searches escape local optima. can conduct basic parsimony search : can instructive inspect progress tree search. , can see many earliest ratchet iterations finding optimal trees previously visited. Later iterations found progressively fewer new trees, suggesting search likely effective. Advanced users might wish visualize progress tree search mapping tree space:  quick glance suggests early ratchet iterations captured large part diversity optimal trees, iterations aren’t getting stuck local optima – though conscientious users ensure mapping tree space meaningful adequate detect structure making firm conclusions (Smith, 2022a). thorough, might consider continuing search little longer, fine-tuning search parameters: happens, best tree dataset score 79 equal weights parsimony. can plot best tree(s) ’ve found, check parsimony score (length):","code":"library(\"TreeSearch\") vinther <- TreeSearch::inapplicable.phyData[[\"Vinther2008\"]] # Set a random seed so that random functions in this document are reproducible RNGversion(\"3.5.0\") ## Warning in RNGkind(\"Mersenne-Twister\", \"Inversion\", \"Rounding\"): non-uniform ## 'Rounding' sampler used set.seed(0) bestTrees <- MaximizeParsimony(vinther) firstHit <- attr(bestTrees, \"firstHit\") firstHit ##   seed  start ratch1 ratch2 ratch3 ratch4 ratch5 ratch6 ratch7  final  ##      0     27      0      0     15      2      6      0      1      0 distances <- TreeDist::ClusteringInfoDistance(bestTrees) searchStages <- length(firstHit) map <- cmdscale(distances, k = 3) cols <- hcl.colors(searchStages, alpha = 0.8) par(mar = rep(0, 4)) TreeDist::Plot3(map,                 col = cols[rep(seq_along(firstHit), firstHit)],                 pch = 16, cex = 2,                 axes = FALSE, xlab = \"\", ylab = \"\", asp = 1) TreeTools::MSTEdges(distances, plot = TRUE, map[, 1], map[, 2],                     col = \"#00000030\", lty = 2) legend(\"topright\", names(firstHit), col = cols, pch = 16, bty = \"n\") bestTrees <- MaximizeParsimony(vinther, tree = bestTrees,                                ratchIter = 6L,                                tbrIter = 4L,                                 finalIter = 3L,                                maxHits = 80L) par(mar = rep(0.25, 4), cex = 0.75) # make plot easier to read plot(ape::consensus(bestTrees)) TreeLength(bestTrees[[1]], vinther) ## [1] 79"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-search.html","id":"evaluating-clade-support","dir":"Articles","previous_headings":"Command line tree search","what":"Evaluating clade support","title":"Getting started: Simple tree searches","text":"might interested labelling clades frequency among sampled -parsimonious trees:  approach sensible way analyse clade credibility frequency split corresponds probability, case Bayesian posterior sample trees. case, however, sets parsimonious trees. Imagine set parsimonious trees expanded include single additional tree Halkieria sister brachiopod Terebratulina (close outgroup). situation Halkieria may brachiopod – case single interpretation molluscan relationships parsimonious – may mollusc, case mosaic characters can reconciled molluscs number equally-parsimonious ways. Neither interpretation considered less plausible, even observe unique parsimonious trees Halkieria mollusc simply greater resultant uncertainty placement taxa Odontogriphus Wiwaxia. instructive measure clade support can generated using Jackknife resampling. Resample() manual page suggestions appropriate numbers replicates search intensity, instructions calculating bootstrap support; code gives quick--run jackknife framework can adapted requirements particular dataset.  Jackknife bootstrap support values give indication volume data supports node, don’t necessarily indicate whether data unanimous existence clade: high bootstrap support value indicate large number characters supporting clade, slightly smaller number characters contradicting . “TreeSearch” implements number concordance measures aim indicate whether dataset unanimous divided support grouping, independently method tree reconstruction.","code":"par(mar = rep(0.25, 4), cex = 0.75) # make plot easier to read majCons <- ape::consensus(bestTrees, p = 0.5) splitFreqs <- TreeTools::SplitFrequency(majCons, bestTrees) / length(bestTrees) plot(majCons) TreeTools::LabelSplits(majCons, round(splitFreqs * 100), unit = \"%\",                        col = TreeTools::SupportColor(splitFreqs),                        frame = \"none\", pos = 3L) nReplicates <- 10 jackTrees <- lapply(logical(nReplicates), function (x)   Resample(vinther, bestTrees, ratchIter = 0, tbrIter = 1, maxHits = 4,            verbosity = 0) )  strict <- ape::consensus(bestTrees, p = 1)  par(mar = rep(0, 4), cex = 0.8) # Take the strict consensus of all trees for each replicate JackLabels(strict, lapply(jackTrees, ape::consensus)) -> XX concordance <- QuartetConcordance(strict, vinther)  # Alternative measures: # concordance <- ClusteringConcordance(strict, vinther) # concordance <- PhylogeneticConcordance(strict, vinther)  par(mar = rep(0, 4), cex = 0.8) plot(strict) TreeTools::LabelSplits(strict, signif(concordance, 3),                        col = TreeTools::SupportColor(concordance / max(concordance)),                        frame = \"none\", pos = 3L)"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-search.html","id":"exploring-taxon-stability","dir":"Articles","previous_headings":"Command line tree search","what":"Exploring taxon stability","title":"Getting started: Simple tree searches","text":"Measure clade support can captures one aspect uncertainty set trees. Often one “rogue” taxon uncertain position can mask agreement relationships taxa (Smith, 2022b). potential impact rogue taxa can explored colouring individual tips according stability tree set:  removing unstable taxon reveal hidden support relationships base Mollusca? can test see whether removal taxon summary tree justified using: case, dropping Wiwaxia improve resolution strict consensus enough justify loss information regarding position (net gain 14.3 bits). informative single summary tree thus provided :  reveals trees agree Halkieria Orthrozanclus closer aculiferan molluscs Odontogriphus Neopilina, fact masked strict consensus due uncertain position Wiwaxia. can see Wiwaxia plot tree using:  Brighter greens indicate trees contained Wiwaxia position. details rogue taxon identification available package “Rogue”.","code":"par(mar = rep(0, 4), cex = 0.8)  plot(strict, tip.color = Rogue::ColByStability(bestTrees)) Rogue::QuickRogue(bestTrees, p = 1) ##   num taxNum   taxon rawImprovement       IC ## 1   0   <NA>    <NA>             NA 154.5491 ## 2   1     21 Wiwaxia       14.32221 168.8713 par(mar = rep(0, 4), cex = 0.8) noWiwaxia <- lapply(bestTrees, TreeTools::DropTip, \"Wiwaxia\") plot(ape::consensus(noWiwaxia), tip.color = Rogue::ColByStability(noWiwaxia)) par(mar = rep(0, 4), cex = 0.8) xx <- TreeTools::RoguePlot(bestTrees, \"Wiwaxia\", p = 1)"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-search.html","id":"implied-weighting","dir":"Articles","previous_headings":"","what":"Implied weighting","title":"Getting started: Simple tree searches","text":"Equal weights produces trees less accurate less precise implied weights (Smith, 2019); equally weighted analysis never conducted without also considering results implied weights (Goloboff, 1993, 1997), ideally range concavity constants (cf. Smith & Ortega-Hernández, 2014). Implied weights can activated simply specifying value concavity constant, k:  Note recommend default value 10, somewhat higher default 3 TNT; low default gives poorer results many settings (Goloboff, Torres, & Arias, 2018; Smith, 2019). Better still use multiple values compare results, perhaps Tree space. Even better (?) use profile parsimony.","code":"iwTrees <- MaximizeParsimony(vinther, concavity = 10) par(mar = rep(0.25, 4), cex = 0.75) # make plot easier to read plot(ape::consensus(iwTrees))"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-search.html","id":"constraining-a-search","dir":"Articles","previous_headings":"","what":"Constraining a search","title":"Getting started: Simple tree searches","text":"sometimes legitimate insist trees must contain certain clade. reduces number tree rearrangements considered, can speed tree search. “TreeSearch” supports soft constraints, can specified using separate Nexus file, creating phyDat object R. Constraints effectively phylogenetic characters; trees character fits perfectly considered. position taxa listed constraint constrained. MaximizeParsimony() attempt find starting tree satisfies constraints, , may necessary specify one manually – perhaps checking constraints contradictory. ’s simple example six taxa enforces bipartition ab | cdef:  ’s complex example imposes splits ab | cef abcd | ef, whilst allowing g plot anywhere tree:  Constraints can also loaded Nexus file constraint <- TreeTools::ReadAsPhyDat(\"constraint_file.nex\").","code":"library(\"TreeTools\", quietly = TRUE) constraint <- MatrixToPhyDat(c(a = 1, b = 1, c = 0, d = 0, e = 0, f = 0)) characters <- MatrixToPhyDat(matrix(   c(0, 1, 1, 1, 0, 0,     1, 1, 1, 0, 0, 0), ncol = 2,   dimnames = list(letters[1:6], NULL))) plot(MaximizeParsimony(characters, constraint = constraint,                        verbosity = -1)[[1]]) characters <- MatrixToPhyDat(matrix(   c(0, 0, 1, 1, 1, 1, 1,     1, 1, 1, 1, 0, 0, 0), ncol = 2,   dimnames = list(letters[1:7], NULL))) constraint <- MatrixToPhyDat(matrix(   c(0, 0, 1, \"?\", 1, 1,     1, 1, 1,   1, 0, 0), ncol = 2,   dimnames = list(letters[1:6], NULL))) plot(MaximizeParsimony(characters, constraint = constraint,                        verbosity = -1)[[1]])"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-search.html","id":"where-next","dir":"Articles","previous_headings":"","what":"Where next?","title":"Getting started: Simple tree searches","text":"Documentation home Guide installation Search trees using standard parsimony (corrected inapplicable data) profile parsimony custom optimality criteria Explore distribution optimal trees mappings","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"loading-trees-into-the-gui","dir":"Articles","previous_headings":"","what":"Loading trees into the GUI","title":"Getting started: Exploring tree space","text":"example uses Sun et al. (2018) dataset included TreeSearch package, contains trees generated four optimality criteria. approach work search results generated tree search within GUI, set trees loaded using “Load trees” function. rapid processing, large tree sets -sampled loaded: , 48 125 trees used analysis. useful obtaining initial overview results; including trees gives complete picture results take quadratically longer generate. loading output Bayesian analysis, may wish modify range trees sampled exclude trees generated burn-phase. Equivalent R code can downloaded using “Save plot: R script” button, provided reference:","code":"# Load required libraries  library(\"TreeTools\", quietly = TRUE)  library(\"TreeDist\")  library(\"TreeSearch\")      # Load Sun et al. 2018 trees from TreeSearch package treeFile <- system.file(\"datasets/Sun2018.nex\", package = \"TreeSearch\")  # Load trees from your own file with # treeFile <- \"Path/to/my.file\" #  # To check and set working directory, use: # getwd() # Should match location of data / tree files  # setwd(\".\") # Replace . with desired/directory to change   # Read all trees from file trees <- read.nexus(treeFile)   # Down-sample to a maximum of 48 trees trees <- trees[unique(as.integer(seq.int(1, length(trees), length.out = 48)))]"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"exploring-the-consensus","dir":"Articles","previous_headings":"","what":"Exploring the consensus","title":"Getting started: Exploring tree space","text":"GUI initially display strict consensus input trees, gaining much information possible removing “rogue” taxa whose position highly variable (Smith, 2022b). trees generated probabilistic sampling process (e.g. Markov Chain) majority rule consensus (figure: Majority = 0.5) may reveal additional resolution, note frequency splits trees found parsimony search correspond split support – strict consensus tree direct interpretation setting. Equivalent R code can downloaded using “Save plot: R script” button within GUI, provided reference:","code":"# Select an appropriate majority value # When analysing parsimony results, this value should be 1. majority <- 0.5  # Identify rogue taxa exclude <- Rogue::QuickRogue(trees, p = majority)$taxon[-1] exclude ## [1] \"Paterimitra\"         \"Yuganotheca_elegans\" # Select a rogue whose positions should be depicted plottedRogue <- exclude[1]  # Remove other excluded taxa from tree consTrees <- lapply(trees, DropTip, setdiff(exclude, plottedRogue))  # Colour tip labels according to their original 'instability' (Smith 2022a) tipCols <- Rogue::ColByStability(trees)  # Our plotted rogue will not appear on the tree tipCols <- tipCols[setdiff(consTrees[[1]]$tip.label, plottedRogue)]    # Set up plotting area  par(  mar = c(0, 0, 0, 0), # Zero margins   cex = 0.8            # Smaller font size  )  # Plot the reduced consensus tree, showing position of our plotted rogue  plotted <- RoguePlot(   trees = consTrees,   tip = plottedRogue,  p = majority,   edgeLength = 1,   tip.color = tipCols  )   # Calculate split concordance concordance <- SplitFrequency(plotted$cons, trees) / length(trees)  # Annotate splits by concordance  LabelSplits(  tree = plotted$cons,  labels = signif(concordance, 3),  col = SupportColor(concordance),  frame = \"none\",  pos = 3 )"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"the-structure-of-tree-space","dir":"Articles","previous_headings":"","what":"The structure of tree space","title":"Getting started: Exploring tree space","text":"“Tree space” display option plots trees points, attempts map distribution points distance mapped points corresponds tree distance pair trees. default method (Clustering Information distance) many advantages widely-used Robinson–Foulds distance (Smith, 2020, 2022a); quartet distance, whilst slower calculate, can also produce good low-dimensional mappings tree space. number dimensions space can reduced make mappings easier interpret, check mapping quality gauge remains least “good”, perceived structure may artefact distortion. dataset, trees assigned three distinct clusters, display “good” structure: clusters marked silhouette coefficient greater threshold, whose interpretation marked slider (, 0.68 “good”). happens, clusters largely correspond tree reconstruction method used: Fitch (1971) parsimony (TNT_EW) trees form one distinct cluster; trees “BGS” inapplicable-corrected parsimony (Brazeau, Guillerme, & Smith, 2019) another; Bayesian trees final, diffuse cluster.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"tree-space-analysis-in-r","dir":"Articles","previous_headings":"The structure of tree space","what":"Tree space analysis in R","title":"Getting started: Exploring tree space","text":"sophisticated tree space analysis can conducted using ‘TreeDist’ package. Sample R code can downloaded using “Save plot: R script” button within GUI, provided reference:","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"generate-distances","dir":"Articles","previous_headings":"The structure of tree space","what":"Generate distances","title":"Getting started: Exploring tree space","text":"Different tree distances reflect different aspects tree similarity, may may relevant phylogenetic questions (Smith, 2020, 2022a).","code":"# Compute distances between pairs of trees dists <- TreeDist::ClusteringInfoDistance(trees) # The quartet distance is a slower alternative: library(\"Quartet\") dists <- as.dist(Quartet::QuartetDivergence(     Quartet::ManyToManyQuartetAgreement(trees), similarity = FALSE) )"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"identify-clustering-structure","dir":"Articles","previous_headings":"The structure of tree space","what":"Identify clustering structure","title":"Getting started: Exploring tree space","text":"compute clusters trees using selection clustering methods (Bien & Tibshirani, 2011; Hartigan & Wong, 1979; Maechler, Rousseeuw, Struyf, Hubert, & Hornik, 2019), allowing optimal clustering highlighted plot.","code":"# Try K-means clustering (Hartigan & Wong 1979): kClusters <- lapply(   2:15, # Minimum 2 clusters; maximum 15   function (k) kmeans(dists, k) ) kSils <- vapply(kClusters, function (kCluster) {   mean(cluster::silhouette(kCluster$cluster, dists)[, 3])  }, double(1))  bestK <- which.max(kSils)  kSil <- kSils[bestK] # Best silhouette coefficient  kCluster <- kClusters[[bestK]]$cluster # Best solution   # Try partitioning around medoids (Maechler et al. 2019): pamClusters <- lapply(2:15, function (k) cluster::pam(dists, k = k))  pamSils <- vapply(pamClusters, function (pamCluster) {   mean(cluster::silhouette(pamCluster)[, 3])  }, double(1))  bestPam <- which.max(pamSils)  pamSil <- pamSils[bestPam] # Best silhouette coefficient  pamCluster <- pamClusters[[bestPam]]$cluster # Best solution   # Try hierarchical clustering with minimax linkage (Bien & Tibshirani 2011): hTree <- protoclust::protoclust(dists)  hClusters <- lapply(2:15, function (k) cutree(hTree, k = k))  hSils <- vapply(hClusters, function (hCluster) {   mean(cluster::silhouette(hCluster, dists)[, 3])  }, double(1))  bestH <- which.max(hSils)  hSil <- hSils[bestH] # Best silhouette coefficient  hCluster <- hClusters[[bestH]] # Best solution  # Set threshold for recognizing meaningful clustering  # no support < 0.25 < weak < 0.5 < good < 0.7 < strong  threshold <- 0.5  # Compare silhouette coefficients of each method  bestMethodId <- which.max(c(threshold, pamSil, hSil, kSil))  bestCluster <- c(\"none\", \"pam\", \"hmm\", \"kmn\")[bestMethodId]   # Best clustering: c(\"Structure below threshold\",   \"Partitioning around medoids\",   \"Hierarchical-minimax\",   \"K-means\")[bestMethodId] ## [1] \"Hierarchical-minimax\" # Best silhouette coefficient: max(c(threshold, pamSil, hSil, kSil)) ## [1] 0.5849486 # Store the cluster to which each tree is optimally assigned:  clustering <- switch(bestCluster, pam = pamCluster, hmm = hCluster, kmn = kCluster, 1)  nClusters <- length(unique(clustering))"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"mapping-tree-space","dir":"Articles","previous_headings":"The structure of tree space","what":"Mapping tree space","title":"Getting started: Exploring tree space","text":"Now can map tree space dimensions visualise distribution trees:","code":"nDim <- 3 # Number of dimensions to plot  # Generate first dimensions of tree space using PCoA  map <- cmdscale(dists, k = nDim)   # Prepare plot layout  nPanels <- nDim * (nDim - 1L) / 2L # Lower-left triangle  plotSeq <- matrix(0, nDim, nDim) plotSeq[upper.tri(plotSeq)] <- seq_len(nPanels) plotSeq[nDim - 1, 2] <- max(plotSeq) + 1L layout(t(plotSeq[-nDim, -1]))  # Set plot margins  par(mar = rep(0.2, 4))  # Set up tree plotting symbols treePch <- 0 # Square clusterCol <- palette.colors(nClusters, \"Alphabet\", alpha = 0.8) treeCols <- clusterCol[clustering] for (i in 2:nDim) for (j in seq_len(i - 1)) {       # Set up blank plot    plot(      x = map[, j],      y = map[, i],      ann = FALSE,        # No annotations      axes = FALSE,       # No axes      frame.plot = TRUE,  # Border around plot      type = \"n\",         # Don't plot any points yet      asp = 1,            # Fix aspect ratio to avoid distortion      xlim = range(map),  # Constant X range for all dimensions      ylim = range(map)   # Constant Y range for all dimensions    )        # Plot minimum spanning tree (Gower 1969) to depict distortion (Smith 2022)   mst <- MSTEdges(as.matrix(dists))    segments(      x0 = map[mst[, 1], j],      y0 = map[mst[, 1], i],      x1 = map[mst[, 2], j],      y1 = map[mst[, 2], i],      col = \"#bbbbbb\", # Light grey      lty = 1          # Solid lines    )        # Add points   points(      x = map[, j],      y = map[, i],      pch = treePch,      col = treeCols,      cex = 1.7, # Point size      lwd = 2 # Line width    )        # Mark clusters    for (clI in seq_len(nClusters)) {      inCluster <- clustering == clI      clusterX <- map[inCluster, j]      clusterY <- map[inCluster, i]      hull <- chull(clusterX, clusterY)      polygon(        x = clusterX[hull],        y = clusterY[hull],        lty = 1, # Solid line style        lwd = 2, # Wider line width        border = clusterCol[clI]      )    }  }"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"using-tree-clustering-to-understand-tree-space-structure","dir":"Articles","previous_headings":"","what":"Using tree clustering to understand tree space structure","title":"Getting started: Exploring tree space","text":"Plotting consensus trees within specific cluster can give insight underlying relationships within tree set viewing single strict consensus, particularly data decisively distinguish small number well-defined conflicting phylogenetic hypotheses (Stockham, Wang, & Warnow, 2002). Visualising consensus cluster can reveal “hidden” agreement trees allow detailed thoughtful analysis meaning phylogenetic output. limited screen space available can render large trees difficult read, may helpful output analysis using “Save plot” options, either R script allow analysis within R, PDF comfortable -screen viewing. R code modified output GUI, order conduct rogue taxon analysis cluster separately. Note draws results clustering analysis .","code":"# Select proportion for majority rule consensus trees # 1 is the appropriate value when parsimony trees are included majority <- 1  # Plot each consensus tree in turn:  for (i in seq_len(nClusters)) {   clusterTrees <- trees[clustering == i]   # Identify rogue taxa for this cluster   clusterRogues <- Rogue::QuickRogue(clusterTrees, p = majority)$taxon[-1]      # Colour tree labels based on stability across cluster   tipCols <- Rogue::ColByStability(clusterTrees)      cons <- ConsensusWithout(      trees = clusterTrees,      tip = clusterRogues,     p = majority   )       # Root tree    cons <- RootTree(cons, trees[[1]]$tip.label[1])      # Set unit edge lengths for viewing   cons$edge.length <- rep.int(1, nrow(cons$edge))       # Rotate nodes, to display clades in order of size    cons <- SortTree(cons, order = names(trees[[1]]$tip.label))      # Plot tree   par(mar = c(0, 0, 0, 0), cex = 0.8) # Set up plotting area   plot(      cons,      edge.width = 2,             # Widen lines      font = 3,                   # Italicize labels      cex = 0.83,                 # Shrink tip font size      edge.color = clusterCol[i], # Colour tree according to previous plot     tip.color = tipCols[cons$tip.label]    )    legend(     \"bottomright\",      paste(\"Cluster\", i),      pch = 15,            # Filled circle icon      pt.cex = 1.5,        # Increase icon size      col = clusterCol[i],      bty = \"n\"            # Don't plot legend in box    )    if (length(clusterRogues)) {     # Mark omitted taxa, if any rogues present     legend(       \"topright\",       clusterRogues,       col = tipCols[clusterRogues],       text.col = tipCols[clusterRogues],       pch = \"-\",      # Mark as excluded       cex = 0.8,      # Smaller font       text.font = 3,  # Italicize       bty = \"n\"       # Don't plot legend in box      )   } }"},{"path":"https://ms609.github.io/TreeSearch/dev/articles/tree-space.html","id":"where-next","dir":"Articles","previous_headings":"Using tree clustering to understand tree space structure","what":"Where next?","title":"Getting started: Exploring tree space","text":"Documentation home Guide installation Search trees using standard parsimony (corrected inapplicable data) profile parsimony custom optimality criteria","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin R. Smith. Author, maintainer, copyright holder. Martin Brazeau. Copyright holder.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Brazeau, M.D., Smith, M.R. & Guillerme, T. (2017). MorphyLib: library phylogenetic analysis categorical trait data inapplicability. doi: 10.5281/zenodo.815371 Brazeau, M.D., Guillerme, T. & Smith, M.R. (2019). algorithm morphological phylogenetic analysis inapplicable data. Systematic Biology 68(4): 619-631. doi: 10.1093/sysbio/syy083 Smith (2018). TreeSearch: phylogenetic analysis discrete character data. doi: 10.5281/zenodo.1042590 Smith (2023). TreeSearch: morphological phylogenetic analysis R. R journal 14:305-315. doi:10.32614/RJ-2023-019 .32614/RJ-2023-019","code":"@Manual{Brazeau2017,   title = {MorphyLib: a library for phylogenetic analysis of categorical trait data with inapplicability},   author = {Martin D. Brazeau and Martin R. Smith and Thomas Guillerme},   year = {2017},   note = {Version 0.0.1-alpha}, } @Article{Brazeau2019,   title = {An algorithm for morphological phylogenetic analysis with inapplicable data},   author = {Martin D. Brazeau and Thomas Guillerme and Martin R. Smith},   journal = {Systematic Biology},   volume = {64},   issue = {4},   pages = {619-631},   year = {2019}, } @Manual{Smith2018,   title = {{TreeSearch}: phylogenetic analysis with discrete character data},   author = {Martin R. Smith},   note = {R package version 1.5.1.9006},   year = {2018},   doi = {10.5281/zenodo.1042590}, } @Article{Smith2023,   title = {{TreeSearch}: morphological phylogenetic analysis in {{R}}},   author = {Martin R. Smith},   year = {2023},   journal = {R Journal},   volume = {14},   number = {4},   pages = {305-315},   doi = {10.32614/RJ-2023-019}, }"},{"path":"https://ms609.github.io/TreeSearch/dev/index.html","id":"treesearch","dir":"","previous_headings":"","what":"Phylogenetic Analysis with Discrete Character Data","title":"Phylogenetic Analysis with Discrete Character Data","text":"“TreeSearch” (Smith 2023) R package contains “shiny” user interface interactive tree search exploration results, including character visualization, rogue taxon detection (Smith 2022a), tree space mapping (Smith 2022b), cluster consensus trees. Inapplicable character states handled using algorithm Brazeau, Guillerme Smith (2019) using “Morphy” C library (Brazeau et al. 2017). Implied weighting (Goloboff, 1993), Profile Parsimony (Faith Trueman, 2001) Successive Approximations (Farris, 1969) implemented; custom optimality criteria search approaches can also defined.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/index.html","id":"installing-in-r","dir":"","previous_headings":"","what":"Installing in R","title":"Phylogenetic Analysis with Discrete Character Data","text":"Full installation instructions, including notes installing R, available vignette. Install load stable version CRAN follows: Install load development version “TreeSearch” :","code":"install.packages(\"TreeSearch\") library(\"TreeSearch\") # Launch the Shiny App with: TreeSearch::EasyTrees() if(!require(\"curl\")) install.packages(\"curl\") if(!require(\"remotes\")) install.packages(\"remotes\") remotes::install_github(\"ms609/TreeSearch\") library(\"TreeSearch\")"},{"path":"https://ms609.github.io/TreeSearch/dev/index.html","id":"installing-stand-alone-application","dir":"","previous_headings":"","what":"Installing stand-alone application","title":"Phylogenetic Analysis with Discrete Character Data","text":"TreeSearch user interface can run stand-alone application without installing R. Download latest release platform. preferred platform supported, please contact maintainer.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/index.html","id":"installation-on-windows","dir":"","previous_headings":"","what":"Installation on Windows","title":"Phylogenetic Analysis with Discrete Character Data","text":"may need obtain ffmpeg library can run TreeSearch. best installed using ‘Chocolatey’. chocolatey installed, open PowerShell window administrative privileges, type choco install ffmpeg; restart computer.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Phylogenetic Analysis with Discrete Character Data","text":"Launch graphical user interface typing TreeSearch::EasyTrees() R console. control search settings, see ?MaximizeParsimony().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Phylogenetic Analysis with Discrete Character Data","text":"Package functions reference manual Getting started Using GUI Analysing tree spaces Loading phylogenetic data R Parsimony search inapplicable data Calculating concavity profiles Profile Parsimony Tree search profile parsimony ‘TreeSearch’ uses semantic versioning. Please note ‘TreeSearch’ project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Phylogenetic Analysis with Discrete Character Data","text":"Brazeau M. D., Smith M. R., Guillerme T. (2017). MorphyLib: library phylogenetic analysis categorical trait data inapplicability. doi: 10.5281/zenodo.815372. Brazeau, M. D., Guillerme, T. Smith, M. R. (2019). algorithm morphological phylogenetic analysis inapplicable data. Systematic Biology, 68(4), 619-631. doi: 10.1093/sysbio/syy083. Faith D. P., Trueman J. W. H. (2001). Towards inclusive philosophy phylogenetic inference. Systematic Biology, 50(3), 331–350. doi: 10.1080/10635150118627. Farris, J. S. (1969). successive approximations approach character weighting. Systematic Biology, 18(4), 374–385. doi: 10.2307/2412182. Goloboff, P. . (1993). Estimating character weights tree search. Cladistics, 9(1), 83–91. doi: 10.1111/j.1096-0031.1993.tb00209.x. Goloboff, P. ., Torres, ., Arias, J. S. (2018). Weighted parsimony outperforms methods phylogenetic inference models appropriate morphology. Cladistics, 34(4), 407–437. doi: 10.1111/cla.12205. Smith, M. R. (2022a). Using information theory detect rogue taxa improve phylogenetic trees. Systematic Biology, 71(5), 1088–1094. doi: 10.1093/sysbio/syab099 Smith, M. R. (2022b). Robust analysis phylogenetic tree space. Systematic Biology, 71(5), 1255–1270. doi: 10.1093/sysbio/syab100 Smith, M. R. (2023). TreeSearch: morphological phylogenetic analysis R. R Journal, 14(4), 305-315. doi: 10.32614/RJ-2023-019","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AdditionTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Addition tree — AdditionTree","title":"Addition tree — AdditionTree","text":"Generates starting tree adding taxon turn parsimonious location.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AdditionTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Addition tree — AdditionTree","text":"","code":"AdditionTree(dataset, concavity = Inf, constraint, sequence)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AdditionTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Addition tree — AdditionTree","text":"dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. concavity Numeric specifying concavity constant implied step weighting. appropriate value depend dataset, values around 10–15 often perform well Goloboff2018,Smith2019TreeSearch. character string \"profile\" employs approximation profile parsimony Faith2001TreeSearch. Set Inf equal step weights, underperforms step weighting approaches Goloboff2008,Goloboff2018,Goloboff2019,Smith2019TreeSearch. constraint Either object class phyDat, case returned trees perfectly compatible character constraint; tree class phylo, whose nodes occur output tree. See ImposeConstraint() vignette examples. sequence Character numeric vector listing sequence add taxa. Randomized provided.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AdditionTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Addition tree — AdditionTree","text":"AdditionTree() returns tree class phylo, rooted sequence[1].","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AdditionTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Addition tree — AdditionTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AdditionTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Addition tree — AdditionTree","text":"","code":"data(\"inapplicable.phyData\", package = \"TreeSearch\") AdditionTree(inapplicable.phyData[[\"Longrich2010\"]], concavity = 10) #>  #> Phylogenetic tree with 20 tips and 19 internal nodes. #>  #> Tip labels: #>   Psittacosaurus_spp, Prenocephale_prenes, Pachycephalosaurus_wyomingensis, Texacephale_langstoni, Hanssuesia_sternbergi, Homalocephale_calathocercos, ... #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AllSPR.html","id":null,"dir":"Reference","previous_headings":"","what":"All SPR trees — AllSPR","title":"All SPR trees — AllSPR","text":"SPR trees","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AllSPR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All SPR trees — AllSPR","text":"","code":"AllSPR(parent, child, nEdge, notDuplicateRoot, edgeToBreak)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AllSPR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"All SPR trees — AllSPR","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. nEdge integer specifying number edges tree class phylo, .e. dim(tree$edge)[1] notDuplicateRoot logical vector length nEdge, specifying edge whether second edge leading root (case breaking equivalent breaking root edge... except insofar moves position root.) edgeToBreak (optional) integer specifying index edge bisect/prune, generated randomly specified. Alternatively, set -1 return complete list trees one step input tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AllSPR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"All SPR trees — AllSPR","text":"AllSPR() returns list edge matrices trees one SPR rearrangement starting tree","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/AllSPR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"All SPR trees — AllSPR","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Carter1.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of trees with m steps — Carter1","title":"Number of trees with m steps — Carter1","text":"Calculate number trees Fitch parsimony reconstruct m steps, leaves labelled one state, b leaves labelled second state.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Carter1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of trees with m steps — Carter1","text":"","code":"Carter1(m, a, b)  Log2Carter1(m, a, b)  LogCarter1(m, a, b)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Carter1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of trees with m steps — Carter1","text":"m Number steps. , b Number leaves labelled 0 1.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Carter1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of trees with m steps — Carter1","text":"Implementation theorem 1 Carter1990;textualTreeTools","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Carter1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number of trees with m steps — Carter1","text":"See also: Steel1993TreeSearch Steel1995TreeSearch (Steel1996TreeSearch)","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Carter1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of trees with m steps — Carter1","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Carter1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of trees with m steps — Carter1","text":"","code":"# The character `0 0 0 1 1 1` Carter1(1, 3, 3) # Exactly one step #> [1] 9 Carter1(2, 3, 3) # Two steps (one extra step) #> [1] 54  # Number of trees that the character can map onto with exactly _m_ steps # if non-parsimonious reconstructions are permitted: cumsum(sapply(1:3, Carter1, 3, 3)) #> [1]   9  63 105  # Three steps allow the character to map onto any of the 105 six-leaf trees."},{"path":"https://ms609.github.io/TreeSearch/dev/reference/CharacterLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Character length — CharacterLength","title":"Character length — CharacterLength","text":"Homoplasy length character dataset specified tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/CharacterLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Character length — CharacterLength","text":"","code":"CharacterLength(tree, dataset, compress = FALSE)  FitchSteps(tree, dataset)  FastCharacterLength(tree, dataset)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/CharacterLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Character length — CharacterLength","text":"tree tree class phylo. dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. compress Logical specifying whether retain compression phyDat object return vector specifying individual character, decompressed using dataset's index attribute.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/CharacterLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Character length — CharacterLength","text":"CharacterLength() returns vector listing contribution character tree score, according algorithm Brazeau2018;textualTreeTools.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/CharacterLength.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Character length — CharacterLength","text":"FastCharacterLength(): perform checks.  Use care: may cause erroneous results software crash variables incorrect format.","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/CharacterLength.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Character length — CharacterLength","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/CharacterLength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Character length — CharacterLength","text":"","code":"data(\"inapplicable.datasets\") dataset <- inapplicable.phyData[[12]] tree <- TreeTools::NJTree(dataset) CharacterLength(tree, dataset) #>   [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  1  2  1  1 #>  [26]  2  2  2  5  1  1  1  2  1  4  3  6  5  5  1  2  1  2  1  1  1  1  1  1  1 #>  [51]  2  1  1  8  3  7  3  3  2  5  2  1  2  2  2  9 10  5  5  2  4  3  5  1  1 #>  [76]  5  6  3  5  5  3  3  2  7  2  1  9  5  7  5  1  7  1  5  2  2  8  1  2  2 #> [101]  1  1  3  2  3  4 12  6  8  4  5  8  7  1  1  2  2  1  1  4  6  2  3  6  6 #> [126]  1  1  1  1  2  1  1  1  2  1  1  6 CharacterLength(tree, dataset, compress = TRUE) #>   [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  2  1  1  2 #>  [26]  2  2  5  1  1  1  2  4  3  6  5  5  1  2  2  2  1  8  3  7  3  3  2  5  2 #>  [51]  1  2  2  9 10  5  5  2  4  3  5  1  1  5  6  3  5  5  3  3  2  7  2  1  9 #>  [76]  5  7  5  1  7  1  5  2  2  8  1  2  2  1  3  2  3  4 12  6  8  4  5  8  7 #> [101]  1  2  2  1  4  6  2  3  6  6  1  1  1  1  2  1  2  6"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ClusterStrings.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster similar strings — ClusterStrings","title":"Cluster similar strings — ClusterStrings","text":"Calculate string similarity using Levenshtein distance return clusters similar strings.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ClusterStrings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster similar strings — ClusterStrings","text":"","code":"ClusterStrings(x, maxCluster = 12)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ClusterStrings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster similar strings — ClusterStrings","text":"x Character vector. maxCluster Integer specifying maximum number clusters consider.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ClusterStrings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster similar strings — ClusterStrings","text":"NameClusters() returns integer assigning element x cluster, attribute med specifying median string cluster, silhouette reporting silhouette coefficient optimal clustering.  Coefficients < 0.5 indicate weak structure, clusters returned.  number unique elements x less maxCluster, occurrences entry assigned individual cluster.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ClusterStrings.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cluster similar strings — ClusterStrings","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ClusterStrings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster similar strings — ClusterStrings","text":"","code":"ClusterStrings(c(paste0(\"FirstCluster \", 1:5),                  paste0(\"SecondCluster.\", 8:12),                  paste0(\"AnotherCluster_\", letters[1:6]))) #>  [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3 #> attr(,\"silhouette\") #> [1] 0.911867 #> attr(,\"med\") #> [1] \"FirstCluster 1\"   \"SecondCluster.10\" \"AnotherCluster_a\""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ConcordantInformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","title":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","text":"Details amount information phylogenetic dataset consistent specified phylogenetic tree, signal:noise ratio character matrix implied tree true.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ConcordantInformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","text":"","code":"ConcordantInformation(tree, dataset)  Evaluate(tree, dataset)  ConcordantInfo(tree, dataset)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ConcordantInformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","text":"tree tree class phylo. dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ConcordantInformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","text":"ConcordantInformation() returns named vector elements: informationContent: cladistic information content dataset signal, noise: amount cladistic information represents phylogenetic signal noise, according tree signalToNoise: implied signal:noise ratio dataset treeInformation: cladistic information content bifurcating tree dataset; minimum amount information necessary resolve bifurcating tree, assuming duplicate information noise matrixToTree: ratio cladistic information content matrix cladistic information content tree, measure redundancy matrix ignored: information content characters whose signal noise calculated (many states) included totals .","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ConcordantInformation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","text":"Presently restricted datasets whose characters contain maximum two parsimony-informative states.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ConcordantInformation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/ConcordantInformation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate the concordance of information between a tree and a dataset — ConcordantInformation","text":"","code":"data(congreveLamsdellMatrices) myMatrix <- congreveLamsdellMatrices[[10]] ConcordantInformation(TreeTools::NJTree(myMatrix), myMatrix) #> dataset contains 821.038 bits, of which 280.813 signal, 540.226 noise, 78.0817 needed.  S:N = 0.519806 #> informationContent             signal              noise      signalToNoise  #>        821.0383923        280.8125010        540.2258914          0.5198057  #>    treeInformation       matrixToTree            ignored  #>         78.0816559         10.5151253          0.0000000"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Consistency.html","id":null,"dir":"Reference","previous_headings":"","what":"Consistency / retention ","title":"Consistency / retention ","text":"Consistency() calculates consistency \"index\" retention index Farris1989TreeSearch character dataset, given bifurcating tree. Although straightforward interpretation indices, sometimes taken indicator fit character tree. Values correlate number species sampled distribution taxa character states, strictly comparable characters factors differ.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Consistency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Consistency / retention ","text":"","code":"Consistency(dataset, tree, compress = FALSE)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Consistency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Consistency / retention ","text":"dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. tree tree class phylo. compress Logical specifying whether retain compression phyDat object return vector specifying individual character, decompressed using dataset's index attribute.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Consistency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Consistency / retention ","text":"Consistency() returns matrix named columns specifying consistency index (ci), retention index (ri), rescaled consistency index (rc).","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Consistency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Consistency / retention ","text":"consistency \"index\" Kluge1969TreeSearch defined number steps observed parsimonious mapping character tree, divided number steps observed shortest possible tree character. value one indicates character's fit tree optimal. Note possible values consistency index range zero one, index mathematical sense term. maximum length character (see MaximumLength()) number steps parsimonious reconstruction longest possible tree character. retention index maximum length character minus number steps observed given tree; divided maximum length minus minimum length.  interpreted ratio observed homoplasy, maximum observed homoplasy, scales zero (worst fit can reconstructed parsimony) one (perfect fit). rescaled consistency index product consistency retention indices; rescales consistency index range possible values runs zero (least consistent) one (perfectly consistent). lengths characters including inapplicable tokens calculated following Brazeau2019;textualTreeSearch, matching default treatment TreeLength().","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Consistency.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Consistency / retention ","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Consistency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Consistency / retention ","text":"","code":"data(inapplicable.datasets) dataset <- inapplicable.phyData[[4]] head(Consistency(dataset, TreeTools::NJTree(dataset))) #>             ci        ri        rc #> [1,] 0.2500000 0.6250000 0.1562500 #> [2,] 0.3333333 0.3333333 0.1111111 #> [3,] 0.3333333 0.6000000 0.2000000 #> [4,] 0.2500000 0.2500000 0.0625000 #> [5,] 0.5000000 0.8333333 0.4166667 #> [6,] 0.2500000 0.2500000 0.0625000"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/DoubleNNI.html","id":null,"dir":"Reference","previous_headings":"","what":"Double NNI — DoubleNNI","title":"Double NNI — DoubleNNI","text":"Returns edge parameter two trees consistent speficied NNI rearrangement","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/DoubleNNI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Double NNI — DoubleNNI","text":"","code":"DoubleNNI(parent, child, edgeToBreak)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/DoubleNNI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Double NNI — DoubleNNI","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. edgeToBreak (optional) integer specifying index edge bisect/prune, generated randomly specified. Alternatively, set -1 return complete list trees one step input tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/DoubleNNI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Double NNI — DoubleNNI","text":"tree[[\"edge\"]] parameter two trees consistent specified rearrangement","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/DoubleNNI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Double NNI — DoubleNNI","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/GapHandler.html","id":null,"dir":"Reference","previous_headings":"","what":"Read how a Morphy Object handles the inapplicable token — GapHandler","title":"Read how a Morphy Object handles the inapplicable token — GapHandler","text":"Gaps represented inapplicable token can treated \"missing data\", .e. equivalent ambiguous token ?; extra state, equivalent states 0 1; \"inapplicable data\" using algorithm Brazeau, Guillerme Smith (2019).","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/GapHandler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read how a Morphy Object handles the inapplicable token — GapHandler","text":"","code":"GapHandler(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/GapHandler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read how a Morphy Object handles the inapplicable token — GapHandler","text":"morphyObj Object class morphy, perhaps created PhyDat2Morphy().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/GapHandler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read how a Morphy Object handles the inapplicable token — GapHandler","text":"GapHandler() returns character string stating gaps handled morphyObj.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/GapHandler.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read how a Morphy Object handles the inapplicable token — GapHandler","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/GapHandler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read how a Morphy Object handles the inapplicable token — GapHandler","text":"","code":"morphyObj <- SingleCharMorphy(\"-0-0\", \"Extra\") GapHandler(morphyObj) #> [1] \"Extra state\" morphyObj <- UnloadMorphy(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/JackLabels.html","id":null,"dir":"Reference","previous_headings":"","what":"Label nodes with jackknife support values — JackLabels","title":"Label nodes with jackknife support values — JackLabels","text":"Label nodes jackknife support values","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/JackLabels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label nodes with jackknife support values — JackLabels","text":"","code":"JackLabels(   tree,   jackTrees,   plot = TRUE,   add = FALSE,   adj = 0,   col = NULL,   frame = \"none\",   pos = 2L,   ... )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/JackLabels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label nodes with jackknife support values — JackLabels","text":"tree tree class phylo. jackTrees list multiPhylo object containing trees generated Jackknife(). plot Logical specifying whether plot results; FALSE, returns blank labels nodes near root correspond unique split. add Logical specifying whether add labels existing plot. adj, col, frame, pos, ... Parameters pass nodelabels().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/JackLabels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label nodes with jackknife support values — JackLabels","text":"named vector specifying proportion jackknife trees consistent node tree, plotted. plot = FALSE, blank entries included corresponding nodes require labelling; return value value required phylo$node.label.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/JackLabels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Label nodes with jackknife support values — JackLabels","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/JackLabels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label nodes with jackknife support values — JackLabels","text":"","code":"library(\"TreeTools\", quietly = TRUE) # for as.phylo  # jackTrees will usually be generated with Jackknife(), but for simplicity: jackTrees <- as.phylo(1:100, 8)  tree <- as.phylo(0, 8) JackLabels(tree, jackTrees)  #>   11   12   13   14   15  #> 0.13 0.08 0.14 1.00 1.00   tree$node.label <- JackLabels(tree, jackTrees, plot = FALSE)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Jackknife.html","id":null,"dir":"Reference","previous_headings":"","what":"Jackknife resampling — Jackknife","title":"Jackknife resampling — Jackknife","text":"Resample trees using Jackknife resampling, .e. removing subset characters.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Jackknife.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jackknife resampling — Jackknife","text":"","code":"Jackknife(   tree,   dataset,   resampleFreq = 2/3,   InitializeData = PhyDat2Morphy,   CleanUpData = UnloadMorphy,   TreeScorer = MorphyLength,   EdgeSwapper = TBRSwap,   jackIter = 5000L,   searchIter = 4000L,   searchHits = 42L,   verbosity = 1L,   ... )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Jackknife.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jackknife resampling — Jackknife","text":"tree tree class phylo. dataset dataset format required TreeScorer(). resampleFreq Double 0 1 stating proportion characters resample. InitializeData Function sets data object prepare tree search. function passed dataset parameter. return value passed TreeScorer() CleanUpData(). CleanUpData Function destroy data object function exit. function passed value returned InitializeData(). TreeScorer function score given tree. function passed three parameters, corresponding parent child entries tree's edge list, dataset. EdgeSwapper function rearranges parent child vector, returns list modified vectors; example SPRSwap(). jackIter Integer specifying number jackknife iterations conduct. searchIter Integer specifying maximum rearrangements perform bootstrap ratchet iteration. override value single swapper function, set e.g. attr(SwapperFunction, \"searchIter\") <- 99 searchHits Integer specifying maximum times hit best score terminating tree search within ratchet iteration. override value single swapper function, set e.g. attr(SwapperFunction, \"searchHits\") <- 99 verbosity Numeric specifying level detail display console: larger numbers provide verbose feedback user. ... arguments pass TreeScorer(), e.g. dataset = .","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Jackknife.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jackknife resampling — Jackknife","text":"Jackknife() returns list trees recovered jackknife iterations.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Jackknife.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Jackknife resampling — Jackknife","text":"function assumes InitializeData() return morphy object; hold , post GitHub issue e-mail maintainer.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Jackknife.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Jackknife resampling — Jackknife","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/LengthAdded.html","id":null,"dir":"Reference","previous_headings":"","what":"Contribution of character to leaf instability — LengthAdded","title":"Contribution of character to leaf instability — LengthAdded","text":"tree lengths change character coded ambiguous leaf Pol2009TreeSearch?","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/LengthAdded.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contribution of character to leaf instability — LengthAdded","text":"","code":"LengthAdded(trees, char, concavity = Inf)  PolEscapa(trees, char, concavity = Inf)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/LengthAdded.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contribution of character to leaf instability — LengthAdded","text":"trees List trees class phylo, multiPhylo object. char phyDat object containing single character. concavity Determines degree extra steps beyond first penalized.  Specify numeric value use implied weighting Goloboff1993TreeSearch; concavity specifies k k / e + k. value 10 recommended; TNT sets default 3, low circumstances Goloboff2018,Smith2019TreeSearch. Better still explore sensitivity results range concavity values, e.g. k = 2 ^ (1:7). Specify Inf weight additional step equally. Specify \"profile\" employ profile parsimony Faith2001TreeSearch.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/LengthAdded.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contribution of character to leaf instability — LengthAdded","text":"LengthAdded() returns named numeric vector listing mean absolute change tree length resulting character coded ambiguous leaf turn, specified concavity constant.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/LengthAdded.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contribution of character to leaf instability — LengthAdded","text":"High values leaf indicate coding contributes instability (\"wildcard\" \"roguish\" behaviour; see Roguefor details). coding tension data, may indicate assumptions homology underlie character's construction scoring require careful scrutiny – taxon question subject convergent evolution. inapplicable tokens present character, applicability coding maintained: .e. leaf coded applicable token never allowed take inapplicable value; inapplicable token remains inapplicable.","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/LengthAdded.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Contribution of character to leaf instability — LengthAdded","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/LengthAdded.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contribution of character to leaf instability — LengthAdded","text":"","code":"trees <- inapplicable.trees[[\"Vinther2008\"]] dataset <- inapplicable.phyData[[\"Vinther2008\"]] char <- dataset[, 11] added <- LengthAdded(trees, char)  PlotCharacter(   tree = trees[[1]],    dataset = char,   tip.color = 1 + added[trees[[1]]$tip.label] # Colour by added steps ) -> XX # Suppress return value; display plot only"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":null,"dir":"Reference","previous_headings":"","what":"Find most parsimonious trees — MaximizeParsimony","title":"Find most parsimonious trees — MaximizeParsimony","text":"Search parsimonious trees using parsimony ratchet TBR rearrangements, treating inapplicable data using algorithm Brazeau2019;textualTreeSearch. Tree search conducted specified automatically-generated starting tree order find tree optimal parsimony score, implied equal weights, treating inapplicable characters order avoid artefacts standard Fitch algorithm @see @Maddison1993; @Brazeau2019TreeSearch. Tree length calculated using MorphyLib C library Brazeau2017TreeSearch.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find most parsimonious trees — MaximizeParsimony","text":"","code":"MaximizeParsimony(   dataset,   tree,   ratchIter = 7L,   tbrIter = 2L,   startIter = 2L,   finalIter = 1L,   maxHits = NTip(dataset) * 1.8,   maxTime = 60,   quickHits = 1/3,   concavity = Inf,   ratchEW = TRUE,   tolerance = sqrt(.Machine[[\"double.eps\"]]),   constraint,   verbosity = 3L )  Resample(   dataset,   tree,   method = \"jack\",   proportion = 2/3,   ratchIter = 1L,   tbrIter = 8L,   finalIter = 3L,   maxHits = 12L,   concavity = Inf,   tolerance = sqrt(.Machine[[\"double.eps\"]]),   constraint,   verbosity = 2L,   ... )  EasyTrees()  EasyTreesy()"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find most parsimonious trees — MaximizeParsimony","text":"dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. tree (optional) bifurcating tree class phylo, containing tips listed dataset, search begin. unspecified, addition tree generated dataset, respecting supplied constraint. Edge lengths supported deleted. ratchIter Numeric specifying number iterations parsimony ratchet Nixon1999TreeSearch conduct. tbrIter Numeric specifying maximum number TBR break points given tree evaluate terminating search. One \"iteration\" comprises selecting branch break, evaluating possible reconnection point turn new tree improves score. better score found, counter reset zero, tree search continues improved tree. startIter Numeric: initial round tree search startIter × tbrIter TBR break points conducted order locate local optimum beginning ratchet searches. finalIter Numeric: final round tree search evaluate finalIter × tbrIter TBR break points, order sample final optimal neighbourhood intensely. maxHits Numeric specifying maximum times optimal parsimony score may hit concluding ratchet iteration final search concluded. maxTime Numeric: maxTime minutes, stop tree search next opportunity. quickHits Numeric: iterations subsampled datasets retain quickHits × maxHits trees best score. concavity Numeric specifying concavity constant implied step weighting. appropriate value depend dataset, values around 10–15 often perform well Goloboff2018,Smith2019TreeSearch. character string \"profile\" employs approximation profile parsimony Faith2001TreeSearch. Set Inf equal step weights, underperforms step weighting approaches Goloboff2008,Goloboff2018,Goloboff2019,Smith2019TreeSearch. ratchEW Logical specifying whether use equal weighting ratchet iterations, improving search speed whilst still facilitating escape local optima. tolerance Numeric specifying degree suboptimality tolerate rejecting tree.  default, sqrt(.Machine$double.eps), retains trees may equally parsimonious rounding errors. Setting larger values include trees suboptimal tolerance search results, may improve accuracy consensus tree (expense resolution) Smith2019TreeSearch. constraint Either object class phyDat, case returned trees perfectly compatible character constraint; tree class phylo, whose nodes occur output tree. See ImposeConstraint() vignette examples. verbosity Integer specifying level messaging; higher values give detailed commentary search progress. Set 0 run silently. method Unambiguous abbreviation jackknife bootstrap specifying resample characters.  Note jackknife considered give meaningful results. proportion Numeric 0 1 specifying proportion characters retain jackknife resampling. ... Additional parameters MaximizeParsimony().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find most parsimonious trees — MaximizeParsimony","text":"MaximizeParsimony() returns list trees class multiPhylo. lists trees found search step within tolerance optimal score, listed sequence first visited, named according step first found; may contain maxHits elements. Note default search parameters may need increased order trees globally optimal trees; examine messages printed tree search evaluate whether optimal score stabilized. return value attribute firstHit, named integer vector listing number optimal trees visited first time stage tree search. Stages named: seed: starting trees; start: Initial TBR search; ratchN: Ratchet iteration N; final: Final TBR search. first tree hit first time ratchet iteration three named ratch3_1. Resample() returns multiPhylo object containing list trees obtained tree search using resampled version dataset.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find most parsimonious trees — MaximizeParsimony","text":"Tree search commences ratchIter iterations parsimony ratchet Nixon1999TreeSearch, bootstraps input dataset order escape local optima. final round tree bisection reconnection (TBR) conducted broaden sampling trees. function can called using R command line / terminal, \"shiny\" graphical user interface app (type EasyTrees() launch). optimal strategy tree search depends part close optimal starting tree , size search space (increases super-exponentially number leaves), complexity search space (e.g. existence multiple local optima). One possible approach employ four phases: Rapid search local optimum: tree score typically easy improve early search, initial tree often far optimal. many moves likely accepted, running several rounds search low value maxHits high value tbrIter allows many trees evaluated quickly, hopefully moving quickly promising region tree space. Identification local optimum: close local optimum, extensive search higher value maxHits allows region explored detail.  Setting high value tbrIter search local neighbourhood completely Search nearby peaks: Ratchet iterations allow escape local optima. Setting ratchIter high value searches wider neighbourhood extensively nearby peaks; ratchEW = TRUE accelerates exploratory searches. Extensive search final optimum.  step 2, may valuable fully explore optimum found ratchet searches sure locally optimal score obtained.  Setting high value finalIter performs thorough search can give confidence searches find better (local) trees. search unlikely found global optimum : Tree score continues improve final iteration.  local optimum yet reached, unlikely global optimum reached. Try increasing maxHits. Successive ratchet iterations continue improve tree scores. recent ratchet iteration improved score, rather finding different region tree space optimal score, likely still better global optima remain found.  Try increasing ratchIter (iterations give chance improvement) maxHits (get closer local optimum ratchet iteration). Optimal areas tree space visited single ratchet iteration. (See vignette: Exploring tree space.) areas tree space found one ratchet iteration, may well , better areas yet visited. Try increasing ratchIter. continuing tree search, usually best start optimal tree found previous iteration – need start scratch. time consuming way checking global optimum reached repeat search parameters multiple times, starting different, entirely random tree time. searches obtain optimal tree score despite different starting points, score likely correspond global optimum. detailed documentation \"TreeSearch\" package, including full instructions loading phylogenetic data R initiating configuring tree search, see package documentation.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":"resampling","dir":"Reference","previous_headings":"","what":"Resampling","title":"Find most parsimonious trees — MaximizeParsimony","text":"Note bootstrap support measure amount data supporting split, rather amount confidence afforded grouping. \"Bootstrap support 100% enough, tree must also correct\" Phillips2004TreeSearch. See discussion Egan2006;textualTreeSearch; Wagele2009;textualTreeSearch; Simmons2011TreeSearch; Kumar2012;textualTreeSearch. discussion suitable search parameters resampling estimates, see Muller2005;textualTreeSearch. user decide whether start resampling optimal tree (may quicker, result overestimated support values searches get stuck local optima close optimal tree) random tree (may take longer rearrangements necessary find optimal tree iteration). ways estimate clade concordance, see SiteConcordance().","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find most parsimonious trees — MaximizeParsimony","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MaximizeParsimony.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find most parsimonious trees — MaximizeParsimony","text":"","code":"## Only run examples in interactive R sessions if (interactive()) {   # launch \"shiny\" point-and-click interface   EasyTrees()      # Here too, use the \"continue search\" function to ensure that tree score   # has stabilized and a global optimum has been found }   # Load data for analysis in R library(\"TreeTools\") data(\"congreveLamsdellMatrices\", package = \"TreeSearch\") dataset <- congreveLamsdellMatrices[[42]]  # A very quick run for demonstration purposes trees <- MaximizeParsimony(dataset, ratchIter = 0, startIter = 0,                            tbrIter = 1, maxHits = 4, maxTime = 1/100,                            concavity = 10, verbosity = 4) #>  #> ── BEGIN TREE SEARCH (k = 10) ────────────────────────────────────────────────── #> → Initial score: 12.6384  #>  #> ── Sample local optimum ──────────────────────────────────────────────────────── #> → TBR depth 1; keeping 4 trees; k = 10 #> ℹ 2025-04-04 14:51:20: Score: 12.6384 #> ✔ 2025-04-04 14:51:21: Tree search terminated with score 12.1193 names(trees) #> [1] \"final_1\"  # In actual use, be sure to check that the score has converged on a global # optimum, conducting additional iterations and runs as necessary.   if (interactive()) { # Jackknife resampling nReplicates <- 10 jackTrees <- replicate(nReplicates,   #c() ensures that each replicate returns a list of trees   c(Resample(dataset, trees, ratchIter = 0, tbrIter = 2, startIter = 1,              maxHits = 5, maxTime = 1 / 10,              concavity = 10, verbosity = 0))  )  # In a serious analysis, more replicates would be conducted, and each # search would undergo more iterations.  # Now we must decide what to do with the multiple optimal trees from # each replicate.  # Treat each tree equally JackLabels(ape::consensus(trees), unlist(jackTrees, recursive = FALSE))  # Take the strict consensus of all trees for each replicate JackLabels(ape::consensus(trees), lapply(jackTrees, ape::consensus))  # Take a single tree from each replicate (the first; order's irrelevant) JackLabels(ape::consensus(trees), lapply(jackTrees, `[[`, 1)) }  # Tree search with a constraint constraint <- MatrixToPhyDat(c(a = 1, b = 1, c = 0, d = 0, e = 0, f = 0)) characters <- MatrixToPhyDat(matrix(   c(0, 1, 1, 1, 0, 0,     1, 1, 1, 0, 0, 0), ncol = 2,   dimnames = list(letters[1:6], NULL))) MaximizeParsimony(characters, constraint = constraint, verbosity = 0) #> ✔ Initialized 1 distinct constraints. #> 1 phylogenetic tree"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MinimumLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum and Maximum lengths possible for a character — MinimumLength","title":"Minimum and Maximum lengths possible for a character — MinimumLength","text":"smallest largest length phylogenetic character can attain tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MinimumLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum and Maximum lengths possible for a character — MinimumLength","text":"","code":"MinimumLength(x, compress = FALSE)  # S3 method for class 'phyDat' MinimumLength(x, compress = FALSE)  # S3 method for class 'numeric' MinimumLength(x, compress = NA)  # S3 method for class 'character' MinimumLength(x, compress = TRUE)  # S3 method for class 'character' MaximumLength(x, compress = TRUE)  MinimumSteps(x)  MaximumLength(x, compress = TRUE)  # S3 method for class 'numeric' MaximumLength(x, compress = NA)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MinimumLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum and Maximum lengths possible for a character — MinimumLength","text":"x object class phyDat; string coerced phyDat object via TreeTools::StringToPhyDat(); integer vector listing tokens may present tip along single character, token represented binary digit; e.g. value 11 ( = 2^0 + 2^1 + 2^3) means tip may tokens 0, 1 3. Inapplicable tokens denoted integer 0 (2^0). compress Logical specifying whether retain compression phyDat object return vector specifying individual character, decompressed using dataset's index attribute.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MinimumLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum and Maximum lengths possible for a character — MinimumLength","text":"MinimumLength() returns vector integers specifying minimum number steps character must contain. MaximumLength() returns vector integers specifying maximum number steps character can attain parsimonious reconstruction tree.  Inapplicable tokens yet supported.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MinimumLength.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Minimum and Maximum lengths possible for a character — MinimumLength","text":"Ambiguous inapplicable states (e.g. {0, -}) currently replaced plain inapplicable token -, reflecting current behaviour Morphy.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MinimumLength.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Minimum and Maximum lengths possible for a character — MinimumLength","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MinimumLength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimum and Maximum lengths possible for a character — MinimumLength","text":"","code":"data(\"inapplicable.datasets\") myPhyDat <- inapplicable.phyData[[4]]  # load your own data with # my.PhyDat <- as.phyDat(read.nexus.data(\"filepath\")) # or Windows users can select a file interactively using: # my.PhyDat <- as.phyDat(read.nexus.data(choose.files()))  class(myPhyDat) # phyDat object #> [1] \"phyDat\"  # Minimum length of each character in turn MinimumLength(myPhyDat) #>   [1] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1 #>  [38] 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 2 1 1 2 1 1 4 3 1 1 1 1 2 1 #>  [75] 1 1 1 1 1 1 2 4 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1  # Collapse duplicate characters, per phyDat compression MinimumLength(myPhyDat, compress = TRUE) #>   [1] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1 #>  [38] 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 2 1 1 2 1 1 4 3 1 1 1 1 2 1 #>  [75] 1 1 1 1 1 1 2 4 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1  # Calculate length of a single character from its textual representation MinimumLength(\"-{-1}{-2}{-3}2233\") #> [1] 2 MaximumLength(\"----0011\") #> [1] 3"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyErrorCheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for error whilst modifying Morphy object — MorphyErrorCheck","title":"Check for error whilst modifying Morphy object — MorphyErrorCheck","text":"Check error whilst modifying Morphy object","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyErrorCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for error whilst modifying Morphy object — MorphyErrorCheck","text":"","code":"MorphyErrorCheck(action)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyErrorCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for error whilst modifying Morphy object — MorphyErrorCheck","text":"action action perform","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyTreeLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate parsimony score from Morphy object — MorphyTreeLength","title":"Calculate parsimony score from Morphy object — MorphyTreeLength","text":"function must passed valid Morphy object, R may crash. users, function TreeLength() appropriate.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyTreeLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate parsimony score from Morphy object — MorphyTreeLength","text":"","code":"MorphyTreeLength(tree, morphyObj)  MorphyLength(   parent,   child,   morphyObj,   inPostorder = FALSE,   nTaxa = mpl_get_numtaxa(morphyObj) )  GetMorphyLength(parentOf, leftChild, rightChild, morphyObj)  C_MorphyLength(parentOf, leftChild, rightChild, morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyTreeLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate parsimony score from Morphy object — MorphyTreeLength","text":"tree tree class phylo, tip labels order generated RenumberTips, .e. corresponding sequence taxa corresponding Morphy object. morphyObj Object class morphy, perhaps created PhyDat2Morphy(). parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. parentOf node, numbered postorder, number parent node. leftChild internal node, numbered postorder, number left child node tip. rightChild internal node, numbered postorder, number right child node tip.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyTreeLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate parsimony score from Morphy object — MorphyTreeLength","text":"MorphyTreeLength() returns length tree, applying weighting.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyTreeLength.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Calculate parsimony score from Morphy object — MorphyTreeLength","text":"MorphyLength(): Faster function requires internal tree parameters. Node numbering must increase monotonically away root. GetMorphyLength(): Fastest function requires internal tree parameters C_MorphyLength(): Direct call C function. Use caution.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyTreeLength.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate parsimony score from Morphy object — MorphyTreeLength","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyWeights.html","id":null,"dir":"Reference","previous_headings":"","what":"Set and get the character weightings associated with a Morphy object. — MorphyWeights","title":"Set and get the character weightings associated with a Morphy object. — MorphyWeights","text":"MorphyWeights() details approximate exact weights associated characters Morphy object; SetMorphyWeights() edits .","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyWeights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set and get the character weightings associated with a Morphy object. — MorphyWeights","text":"","code":"MorphyWeights(morphyObj)  SetMorphyWeights(weight, morphyObj, checkInput = TRUE)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyWeights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set and get the character weightings associated with a Morphy object. — MorphyWeights","text":"morphyObj Object class morphy, perhaps created PhyDat2Morphy(). weight vector listing new weights applied character checkInput Whether sanity-check input data applying. Defaults TRUE protect user crashes.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyWeights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set and get the character weightings associated with a Morphy object. — MorphyWeights","text":"MorphyWeights() returns data frame two named rows one column per character pattern: row 1, approx, list integers specifying approximate (integral) weights used MorphyLib; row 2, exact, list numerics specifying exact weights specified user. SetMorphyWeights() returns Morphy error code generated applying weight.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyWeights.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Set and get the character weightings associated with a Morphy object. — MorphyWeights","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/MorphyWeights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set and get the character weightings associated with a Morphy object. — MorphyWeights","text":"","code":"tokens <- matrix(c(   0, 0, 0, 1, 1, 2,   0, 0, 0, 0, 0, 0), byrow = TRUE, nrow = 2L,   dimnames = list(letters[1:2], NULL)) pd <- TreeTools::MatrixToPhyDat(tokens) morphyObj <- PhyDat2Morphy(pd) MorphyWeights(morphyObj) #>        [,1] [,2] [,3] #> approx 3    2    1    #> exact  3    2    1    if (SetMorphyWeights(c(1, 1.5, 2/3), morphyObj) != 0L) message(\"Errored\") MorphyWeights(morphyObj) #>        [,1] [,2] [,3]      #> approx 6    9    4         #> exact  1    1.5  0.6666667 morphyObj <- UnloadMorphy(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":null,"dir":"Reference","previous_headings":"","what":"Nearest neighbour interchange (NNI) — NNI","title":"Nearest neighbour interchange (NNI) — NNI","text":"NNI()performs single iteration nearest-neighbour interchange algorithm; RootedNNI() retains position root. functions based equivalents phangorn package. cNNI() equivalent function coded C, runs much faster.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nearest neighbour interchange (NNI) — NNI","text":"","code":"NNI(tree, edgeToBreak = NULL)  cNNI(tree, edgeToBreak = NULL, whichSwitch = NULL)  NNISwap(parent, child, nTips = (length(parent)/2L) + 1L, edgeToBreak = NULL)  RootedNNI(tree, edgeToBreak = NULL)  RootedNNISwap(   parent,   child,   nTips = (length(parent)/2L) + 1L,   edgeToBreak = NULL )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nearest neighbour interchange (NNI) — NNI","text":"tree tree class phylo. edgeToBreak (Rooted)NNI(), optional integer specifying index edge bisect/prune, generated randomly specified. -1, complete list trees one step input tree returned. cNNI(), integer zero nEdge(tree) - nTip(tree) - 2, specifying internal edge break. whichSwitch Integer zero one, specifying way re-build broken internal edge. parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. nTips (optional) Number tips.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nearest neighbour interchange (NNI) — NNI","text":"Returns tree class phylo (returnAll = FALSE) set trees, class multiPhylo (returnAll = TRUE). cNNI() returns tree class phylo, rooted leaf, specified rearrangement conducted. NNISwap() returns list containing two elements, corresponding turn  rearranged parent child parameters. list containing two elements, corresponding turn rearranged parent child parameters","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nearest neighbour interchange (NNI) — NNI","text":"Branch lengths supported. nodes tree must bifurcating; ape::collapse.singles() ape::multi2di() may help.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Nearest neighbour interchange (NNI) — NNI","text":"NNISwap(): faster version takes returns parent child parameters RootedNNI(): Perform NNI rearrangement, retaining position root RootedNNISwap(): faster version takes returns parent child parameters","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nearest neighbour interchange (NNI) — NNI","text":"algorithm summarized Felsenstein2004TreeSearch","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Nearest neighbour interchange (NNI) — NNI","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/NNI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nearest neighbour interchange (NNI) — NNI","text":"","code":"tree <- TreeTools::BalancedTree(8) # A random rearrangement NNI(tree) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length. cNNI(tree) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length.  # All trees one NNI rearrangement away NNI(tree, edgeToBreak = -1) #> 12 phylogenetic trees  # Manual random sampling cNNI(tree, sample.int(14 - 8 - 1, 1), sample.int(2, 1)) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length.  # A specified rearrangement cNNI(tree, 0, 0) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length.  # If a tree may not be binary, collapse nodes with tree <- TreeTools::MakeTreeBinary(tree)  # If a tree may be improperly rooted, use tree <- TreeTools::RootTree(tree, 1)  # If a tree may exhibit unusual node ordering, this can be addressed with tree <- TreeTools::Preorder(tree)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PhyDat2Morphy.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize a Morphy object from a phyDat object — PhyDat2Morphy","title":"Initialize a Morphy object from a phyDat object — PhyDat2Morphy","text":"Creates new Morphy object size characters phyDat object. finished object, destroyed using UnloadMorphy() free allocated memory.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PhyDat2Morphy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize a Morphy object from a phyDat object — PhyDat2Morphy","text":"","code":"PhyDat2Morphy(phy, gap = \"inapplicable\")"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PhyDat2Morphy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize a Morphy object from a phyDat object — PhyDat2Morphy","text":"phy object phangorn class phyDat. gap unambiguous abbreviation inapplicable, ambiguous (= missing), extra state, specifying gaps handled.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PhyDat2Morphy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize a Morphy object from a phyDat object — PhyDat2Morphy","text":"PhyDat2Morphy() returns pointer initialized Morphy object.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PhyDat2Morphy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Initialize a Morphy object from a phyDat object — PhyDat2Morphy","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PhyDat2Morphy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialize a Morphy object from a phyDat object — PhyDat2Morphy","text":"","code":"data(\"Lobo\", package=\"TreeTools\") morphyObj <- PhyDat2Morphy(Lobo.phy) # Set object to be destroyed at end of session or closure of function # on.exit(morphyObj <- UnloadMorphy(morphyObj), add = TRUE)  # Do something with pointer # ....  # Or, instead of on.exit, manually destroy morphy object and free memory: morphyObj <- UnloadMorphy(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PlotCharacter.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the distribution of a character on a tree — PlotCharacter","title":"Plot the distribution of a character on a tree — PlotCharacter","text":"Reconstructs distribution character tree topology using modified Fitch algorithm presented Brazeau2019;textualTreeSearch.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PlotCharacter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the distribution of a character on a tree — PlotCharacter","text":"","code":"PlotCharacter(   tree,   dataset,   char = 1L,   updateTips = FALSE,   plot = TRUE,   tokenCol = NULL,   ambigCol = \"grey\",   inappCol = \"lightgrey\",   ambigLty = \"dotted\",   inappLty = \"dashed\",   plainLty = par(\"lty\"),   tipOffset = 1,   unitEdge = FALSE,   Display = function(tree) tree,   ... )  # S3 method for class 'phylo' PlotCharacter(   tree,   dataset,   char = 1L,   updateTips = FALSE,   plot = TRUE,   tokenCol = NULL,   ambigCol = \"grey\",   inappCol = \"lightgrey\",   ambigLty = \"dotted\",   inappLty = \"dashed\",   plainLty = par(\"lty\"),   tipOffset = 1,   unitEdge = FALSE,   Display = function(tree) tree,   ... )  # S3 method for class 'multiPhylo' PlotCharacter(   tree,   dataset,   char = 1L,   updateTips = FALSE,   plot = TRUE,   tokenCol = NULL,   ambigCol = \"grey\",   inappCol = \"lightgrey\",   ambigLty = \"dotted\",   inappLty = \"dashed\",   plainLty = par(\"lty\"),   tipOffset = 1,   unitEdge = FALSE,   Display = function(tree) tree,   ... )  # S3 method for class 'list' PlotCharacter(   tree,   dataset,   char = 1L,   updateTips = FALSE,   plot = TRUE,   tokenCol = NULL,   ambigCol = \"grey\",   inappCol = \"lightgrey\",   ambigLty = \"dotted\",   inappLty = \"dashed\",   plainLty = par(\"lty\"),   tipOffset = 1,   unitEdge = FALSE,   Display = function(tree) tree,   ... )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PlotCharacter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the distribution of a character on a tree — PlotCharacter","text":"tree bifurcating tree class phylo, list multiPhylo object containing trees. dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. char Index character plot. updateTips Logical; FALSE, tips labelled original state dataset. plot Logical specifying whether plot output. tokenCol Palette specifying colours associate token turn, sequence listed attr(dataset, \"levels\"). ambigCol, ambigLty, inappCol, inappLty, plainLty Colours line types apply ambiguous, inapplicable applicable tokens.  See lty graphical parameter details line styles.  Overrides tokenCol. tipOffset Numeric: much offset tips labels. unitEdge Logical: edges plotted unit length? Display Function takes argument tree returns tree class phylo, formatted plotted. ... arguments pass plot.phylo().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PlotCharacter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the distribution of a character on a tree — PlotCharacter","text":"PlotCharacter() invisibly returns matrix row corresponds numbered tip node tree, column corresponds token; tokens might parsimoniously present point tree denoted TRUE. multiple trees supplied, strict consensus trees reconstructions returned; .e. node reconstructed $0$ one tree, $2$ another, labelled $(02)$.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PlotCharacter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot the distribution of a character on a tree — PlotCharacter","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PlotCharacter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the distribution of a character on a tree — PlotCharacter","text":"","code":"# Set up plotting area oPar <- par(mar = rep(0, 4))  tree <- ape::read.tree(text =    \"((((((a, b), c), d), e), f), (g, (h, (i, (j, (k, l))))));\") ## A character with inapplicable data dataset <- TreeTools::StringToPhyDat(\"23--1??--032\", tips = tree) plotted <- PlotCharacter(tree, dataset)  plotted #>           -     0     1     2     3 #>  [1,] FALSE FALSE FALSE  TRUE FALSE #>  [2,] FALSE FALSE FALSE FALSE  TRUE #>  [3,]  TRUE FALSE FALSE FALSE FALSE #>  [4,]  TRUE FALSE FALSE FALSE FALSE #>  [5,] FALSE FALSE  TRUE FALSE FALSE #>  [6,]  TRUE  TRUE  TRUE  TRUE  TRUE #>  [7,]  TRUE  TRUE  TRUE  TRUE  TRUE #>  [8,]  TRUE FALSE FALSE FALSE FALSE #>  [9,]  TRUE FALSE FALSE FALSE FALSE #> [10,] FALSE  TRUE FALSE FALSE FALSE #> [11,] FALSE FALSE FALSE FALSE  TRUE #> [12,] FALSE FALSE FALSE  TRUE FALSE #> [13,]  TRUE FALSE FALSE FALSE FALSE #> [14,]  TRUE FALSE FALSE FALSE FALSE #> [15,]  TRUE FALSE FALSE FALSE FALSE #> [16,]  TRUE FALSE FALSE FALSE FALSE #> [17,]  TRUE FALSE FALSE FALSE FALSE #> [18,] FALSE FALSE FALSE  TRUE  TRUE #> [19,]  TRUE FALSE FALSE FALSE FALSE #> [20,]  TRUE FALSE FALSE FALSE FALSE #> [21,]  TRUE FALSE FALSE FALSE FALSE #> [22,] FALSE  TRUE FALSE  TRUE  TRUE #> [23,] FALSE  TRUE FALSE  TRUE  TRUE  # Character from a real dataset  data(\"Lobo\", package = \"TreeTools\") dataset <- Lobo.phy tree <- TreeTools::NJTree(dataset) PlotCharacter(tree, dataset, 14)  par(oPar)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PrepareDataProfile.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data for Profile Parsimony — PrepareDataProfile","title":"Prepare data for Profile Parsimony — PrepareDataProfile","text":"Calculates profiles character dataset.  also simplify characters, warning, complex present implementation profile parsimony: inapplicable tokens replaced ambiguous token (.e. - → ?); Ambiguous tokens treated fully ambiguous (.e. {02} → ?) two states informative (.e. unambiguously present one taxon), states beyond two informative ignored.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PrepareDataProfile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data for Profile Parsimony — PrepareDataProfile","text":"","code":"PrepareDataProfile(dataset)  PrepareDataIW(dataset)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PrepareDataProfile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data for Profile Parsimony — PrepareDataProfile","text":"dataset dataset class phyDat","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PrepareDataProfile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data for Profile Parsimony — PrepareDataProfile","text":"object class phyDat, additional attributes. PrepareDataProfile adds attributes: info.amounts: details information represented character subject N additional steps. informative: logical specifying characters contain phylogenetic information. bootstrap: character vector c(\"info.amounts\", \"split.sizes\"), indicating attributes sample bootstrapping dataset (e.g. Ratchet searches). PrepareDataIW adds attribute: min.length: minimum number steps must present transformation series.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PrepareDataProfile.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Prepare data for Profile Parsimony — PrepareDataProfile","text":"PrepareDataIW(): Prepare data implied weighting","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PrepareDataProfile.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Prepare data for Profile Parsimony — PrepareDataProfile","text":"Martin R. Smith; written reference phangorn:::prepareDataFitch()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/PrepareDataProfile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare data for Profile Parsimony — PrepareDataProfile","text":"","code":"data(\"congreveLamsdellMatrices\") dataset <- congreveLamsdellMatrices[[42]] PrepareDataProfile(dataset) #> $`1` #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [39] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  #> $`2` #>  [1] 1 2 2 1 2 2 2 2 2 1 1 1 2 1 1 2 1 1 2 1 1 1 2 2 2 2 1 1 1 1 2 2 2 1 2 2 2 2 #> [39] 1 2 1 1 2 1 1 2 1 1 2 2 2 2 2 1 1 #>  #> $`3` #>  [1] 1 1 2 1 2 2 1 2 1 1 1 1 2 1 1 2 2 1 2 1 2 1 2 2 2 2 2 1 1 1 2 1 2 1 1 2 2 2 #> [39] 1 2 1 1 2 2 2 2 1 1 2 2 2 2 2 1 1 #>  #> $`4` #>  [1] 1 1 2 1 2 2 1 2 1 1 2 1 2 1 1 1 2 1 2 1 1 1 2 2 2 2 1 1 1 1 2 1 2 1 1 2 2 2 #> [39] 1 2 1 1 2 2 2 2 1 1 2 1 1 2 2 2 1 #>  #> $`5` #>  [1] 2 1 2 1 2 1 1 2 1 1 2 2 2 1 1 2 2 2 2 1 1 1 2 2 2 2 2 2 2 1 2 1 2 1 2 2 2 2 #> [39] 1 2 1 2 2 2 2 2 1 1 1 1 1 2 2 1 1 #>  #> $`6` #>  [1] 1 1 1 1 2 1 2 2 2 1 1 2 2 1 1 2 1 2 2 1 2 1 1 1 2 2 2 1 2 1 2 2 2 1 2 2 2 1 #> [39] 1 1 1 2 1 2 1 2 2 1 2 1 1 2 2 1 2 #>  #> $`7` #>  [1] 1 1 2 1 2 2 1 1 2 2 1 2 1 1 1 2 2 2 2 2 1 1 1 1 2 2 2 1 2 1 2 1 2 1 1 1 2 1 #> [39] 1 2 1 2 2 1 1 2 2 1 2 1 1 2 2 1 1 #>  #> $`8` #>  [1] 1 2 2 1 2 2 1 2 1 1 1 2 2 1 2 2 1 2 2 1 1 1 2 2 2 1 2 2 1 1 1 1 1 2 2 2 2 1 #> [39] 2 1 1 2 1 2 2 2 2 1 2 2 1 2 2 1 1 #>  #> $`9` #>  [1] 1 1 1 1 2 1 2 2 1 1 2 2 1 1 1 2 1 2 2 1 1 1 1 1 1 1 2 1 2 1 1 2 1 1 2 2 2 1 #> [39] 2 1 1 1 1 2 1 2 1 2 2 1 1 2 1 1 1 #>  #> $`10` #>  [1] 1 1 1 1 2 2 2 1 1 1 2 2 1 1 2 2 1 2 2 1 2 1 1 1 1 2 2 2 2 2 1 1 1 2 1 1 2 2 #> [39] 1 1 2 1 1 2 1 2 1 1 2 1 1 2 2 1 1 #>  #> $`11` #>  [1] 1 1 1 2 2 2 2 1 2 1 2 2 2 1 1 2 1 2 2 1 2 2 2 2 1 1 1 1 2 2 1 2 1 1 2 1 2 1 #> [39] 1 2 1 1 1 2 2 2 1 1 2 1 1 1 1 1 1 #>  #> $`12` #>  [1] 1 1 2 1 2 2 2 1 1 1 1 1 2 1 1 2 1 2 1 1 2 1 1 1 1 1 2 2 2 2 1 2 1 1 2 1 2 2 #> [39] 1 2 2 1 1 2 1 2 1 1 1 1 1 1 1 1 1 #>  #> $`19` #>  [1] 1 1 1 1 2 2 2 2 1 1 1 1 1 1 2 2 1 1 1 1 2 1 2 2 1 2 1 1 1 2 2 2 1 1 1 1 1 2 #> [39] 1 2 2 2 1 2 1 2 1 1 2 1 1 2 1 1 1 #>  #> $`18` #>  [1] 1 1 1 2 2 1 2 1 1 1 2 2 2 1 1 2 1 1 1 1 2 2 2 1 1 1 1 1 2 2 1 2 1 1 1 1 2 2 #> [39] 1 2 1 2 1 1 1 1 2 1 2 1 1 1 2 2 1 #>  #> $`17` #>  [1] 1 2 1 2 1 2 2 2 1 1 2 2 1 1 1 2 1 2 1 1 2 2 2 2 1 1 1 1 1 2 1 1 1 2 1 1 2 1 #> [39] 1 2 1 2 1 1 2 2 1 2 2 1 1 2 1 2 2 #>  #> $`15` #>  [1] 2 2 1 1 2 1 2 2 1 2 2 2 1 1 1 2 1 2 1 1 2 2 2 1 1 2 2 1 1 2 1 1 1 1 2 1 2 2 #> [39] 2 2 1 2 1 1 2 2 2 1 1 2 1 1 2 2 1 #>  #> $`16` #>  [1] 1 1 1 1 1 1 2 1 1 2 1 2 1 1 2 2 1 2 1 1 2 2 1 1 1 2 1 1 1 2 2 1 1 1 2 1 2 1 #> [39] 1 2 2 2 1 1 2 2 2 1 2 2 1 1 2 2 2 #>  #> $`13` #>  [1] 1 2 2 1 2 1 1 2 1 1 2 2 1 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 2 2 2 1 1 2 1 1 2 2 #> [39] 2 2 1 2 1 2 2 1 2 1 1 1 1 1 2 1 2 #>  #> $`14` #>  [1] 2 1 2 1 2 1 1 1 2 2 1 2 1 1 1 1 1 1 1 1 2 1 2 1 2 1 1 1 2 2 1 1 1 2 1 1 2 2 #> [39] 2 2 1 2 1 1 1 1 2 1 2 2 1 1 2 1 2 #>  #> $`20` #>  [1] 1 1 2 1 2 1 2 1 1 1 2 1 1 2 1 1 1 2 2 1 1 1 1 1 1 2 1 1 2 1 1 2 1 1 1 1 1 2 #> [39] 1 2 2 1 1 2 1 1 1 1 2 1 1 2 1 1 1 #>  #> $`21` #>  [1] 1 1 2 1 2 2 2 2 1 1 2 1 1 2 1 2 1 2 1 2 1 1 1 1 1 1 1 1 2 1 1 2 2 1 1 1 1 2 #> [39] 1 2 2 1 1 2 2 2 1 1 1 1 1 2 1 1 2 #>  #> $`22` #>  [1] 2 1 2 1 2 2 2 2 1 1 2 1 1 2 1 2 1 2 1 2 1 1 1 2 1 1 1 1 2 1 1 2 2 1 1 1 1 1 #> [39] 1 2 1 2 2 2 2 2 1 1 2 1 1 2 1 1 2 #>  #> attr(,\"class\") #> [1] \"phyDat\" #> attr(,\"weight\") #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [39] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> attr(,\"nr\") #> [1] 55 #> attr(,\"nc\") #> [1] 2 #> attr(,\"index\") #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #> [51] 51 52 53 54 55 #> attr(,\"levels\") #> [1] \"0\" \"1\" #> attr(,\"allLevels\") #> [1] \"0\" \"1\" \"?\" #> attr(,\"type\") #> [1] \"USER\" #> attr(,\"contrast\") #>      0 1 #> [1,] 1 0 #> [2,] 0 1 #> [3,] 1 1 #> attr(,\"info.amounts\") #>         [,1]      [,2]      [,3]     [,4]     [,5]      [,6]      [,7] #> 1   0.000000  0.000000  0.000000 0.000000 0.000000  0.000000  0.000000 #> 2   5.285402  5.285402  5.285402 5.285402 5.285402  5.285402  5.285402 #> 3   9.150901  9.241099  9.345992 8.909893 8.909893  9.345992  9.330469 #> 4  11.717248 12.160268 12.570623 0.000000 0.000000 12.570623 12.515059 #> 5   0.000000 13.954287 15.099350 0.000000 0.000000 15.099350 14.964820 #> 6   0.000000  0.000000 16.993755 0.000000 0.000000 16.993755 16.718906 #> 7   0.000000  0.000000 18.287328 0.000000 0.000000 18.287328 17.781620 #> 8   0.000000  0.000000 19.024174 0.000000 0.000000 19.024174 18.191556 #> 9   0.000000  0.000000 19.314029 0.000000 0.000000 19.314029  0.000000 #> 10  0.000000  0.000000 19.364620 0.000000 0.000000 19.364620  0.000000 #> 11  0.000000  0.000000  0.000000 0.000000 0.000000  0.000000  0.000000 #>         [,8]      [,9]     [,10]     [,11]     [,12]     [,13]    [,14] #> 1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 0.000000 #> 2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402 5.285402 #> 3   9.340527  9.241099  9.150901  9.345992  9.340527  9.340527 8.909893 #> 4  12.551238 12.160268 11.717248 12.570623 12.551238 12.551238 0.000000 #> 5  15.052965 13.954287  0.000000 15.099350 15.052965 15.052965 0.000000 #> 6  16.900419  0.000000  0.000000 16.993755 16.900419 16.900419 0.000000 #> 7  18.118578  0.000000  0.000000 18.287328 18.118578 18.118578 0.000000 #> 8  18.748741  0.000000  0.000000 19.024174 18.748741 18.748741 0.000000 #> 9  18.928521  0.000000  0.000000 19.314029 18.928521 18.928521 0.000000 #> 10  0.000000  0.000000  0.000000 19.364620  0.000000  0.000000 0.000000 #> 11  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 0.000000 #>        [,15]     [,16]     [,17]     [,18]     [,19]    [,20]     [,21] #> 1   0.000000  0.000000  0.000000  0.000000  0.000000 0.000000  0.000000 #> 2   5.285402  5.285402  5.285402  5.285402  5.285402 5.285402  5.285402 #> 3   9.150901  9.241099  9.150901  9.330469  9.347729 8.909893  9.347729 #> 4  11.717248 12.160268 11.717248 12.515059 12.576744 0.000000 12.576744 #> 5   0.000000 13.954287  0.000000 14.964820 15.113879 0.000000 15.113879 #> 6   0.000000  0.000000  0.000000 16.718906 17.022695 0.000000 17.022695 #> 7   0.000000  0.000000  0.000000 17.781620 18.339056 0.000000 18.339056 #> 8   0.000000  0.000000  0.000000 18.191556 19.107959 0.000000 19.107959 #> 9   0.000000  0.000000  0.000000  0.000000 19.432730 0.000000 19.432730 #> 10  0.000000  0.000000  0.000000  0.000000 19.504816 0.000000 19.504816 #> 11  0.000000  0.000000  0.000000  0.000000 19.509010 0.000000 19.509010 #>        [,22]     [,23]     [,24]     [,25]     [,26]     [,27]     [,28] #> 1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 #> 2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402  5.285402 #> 3   9.241099  9.345992  9.340527  9.340527  9.347729  9.340527  9.150901 #> 4  12.160268 12.570623 12.551238 12.551238 12.576744 12.551238 11.717248 #> 5  13.954287 15.099350 15.052965 15.052965 15.113879 15.052965  0.000000 #> 6   0.000000 16.993755 16.900419 16.900419 17.022695 16.900419  0.000000 #> 7   0.000000 18.287328 18.118578 18.118578 18.339056 18.118578  0.000000 #> 8   0.000000 19.024174 18.748741 18.748741 19.107959 18.748741  0.000000 #> 9   0.000000 19.314029 18.928521 18.928521 19.432730 18.928521  0.000000 #> 10  0.000000 19.364620  0.000000  0.000000 19.504816  0.000000  0.000000 #> 11  0.000000  0.000000  0.000000  0.000000 19.509010  0.000000  0.000000 #>        [,29]     [,30]     [,31]     [,32]     [,33]     [,34]     [,35] #> 1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 #> 2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402  5.285402 #> 3   9.340527  9.345992  9.340527  9.345992  9.330469  9.241099  9.340527 #> 4  12.551238 12.570623 12.551238 12.570623 12.515059 12.160268 12.551238 #> 5  15.052965 15.099350 15.052965 15.099350 14.964820 13.954287 15.052965 #> 6  16.900419 16.993755 16.900419 16.993755 16.718906  0.000000 16.900419 #> 7  18.118578 18.287328 18.118578 18.287328 17.781620  0.000000 18.118578 #> 8  18.748741 19.024174 18.748741 19.024174 18.191556  0.000000 18.748741 #> 9  18.928521 19.314029 18.928521 19.314029  0.000000  0.000000 18.928521 #> 10  0.000000 19.364620  0.000000 19.364620  0.000000  0.000000  0.000000 #> 11  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 #>        [,36]     [,37]     [,38]     [,39]     [,40]     [,41]     [,42] #> 1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 #> 2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402  5.285402 #> 3   9.313959  9.241099  9.340527  9.241099  9.241099  9.287129  9.345992 #> 4  12.454214 12.160268 12.551238 12.160268 12.160268 12.351120 12.570623 #> 5  14.811609 13.954287 15.052965 13.954287 13.954287 14.535765 15.099350 #> 6  16.389045  0.000000 16.900419  0.000000  0.000000 15.738559 16.993755 #> 7  17.137108  0.000000 18.118578  0.000000  0.000000  0.000000 18.287328 #> 8   0.000000  0.000000 18.748741  0.000000  0.000000  0.000000 19.024174 #> 9   0.000000  0.000000 18.928521  0.000000  0.000000  0.000000 19.314029 #> 10  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 19.364620 #> 11  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 #>        [,43]     [,44]     [,45]     [,46]     [,47]    [,48]     [,49] #> 1   0.000000  0.000000  0.000000  0.000000  0.000000 0.000000  0.000000 #> 2   5.285402  5.285402  5.285402  5.285402  5.285402 5.285402  5.285402 #> 3   9.287129  9.330469  9.347729  9.241099  9.330469 0.000000  9.287129 #> 4  12.351120 12.515059 12.576744 12.160268 12.515059 0.000000 12.351120 #> 5  14.535765 14.964820 15.113879 13.954287 14.964820 0.000000 14.535765 #> 6  15.738559 16.718906 17.022695  0.000000 16.718906 0.000000 15.738559 #> 7   0.000000 17.781620 18.339056  0.000000 17.781620 0.000000  0.000000 #> 8   0.000000 18.191556 19.107959  0.000000 18.191556 0.000000  0.000000 #> 9   0.000000  0.000000 19.432730  0.000000  0.000000 0.000000  0.000000 #> 10  0.000000  0.000000 19.504816  0.000000  0.000000 0.000000  0.000000 #> 11  0.000000  0.000000 19.509010  0.000000  0.000000 0.000000  0.000000 #>        [,50]    [,51]     [,52]     [,53]     [,54]     [,55] #> 1   0.000000 0.000000  0.000000  0.000000  0.000000  0.000000 #> 2   5.285402 5.285402  5.285402  5.285402  5.285402  5.285402 #> 3   9.287129 0.000000  9.330469  9.340527  9.241099  9.313959 #> 4  12.351120 0.000000 12.515059 12.551238 12.160268 12.454214 #> 5  14.535765 0.000000 14.964820 15.052965 13.954287 14.811609 #> 6  15.738559 0.000000 16.718906 16.900419  0.000000 16.389045 #> 7   0.000000 0.000000 17.781620 18.118578  0.000000 17.137108 #> 8   0.000000 0.000000 18.191556 18.748741  0.000000  0.000000 #> 9   0.000000 0.000000  0.000000 18.928521  0.000000  0.000000 #> 10  0.000000 0.000000  0.000000  0.000000  0.000000  0.000000 #> 11  0.000000 0.000000  0.000000  0.000000  0.000000  0.000000 #> attr(,\"informative\") #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> attr(,\"bootstrap\") #> [1] \"info.amounts\""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/QuartetResolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Relationship between four taxa — QuartetResolution","title":"Relationship between four taxa — QuartetResolution","text":"Relationship four taxa","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/QuartetResolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relationship between four taxa — QuartetResolution","text":"","code":"QuartetResolution(trees, tips)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/QuartetResolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relationship between four taxa — QuartetResolution","text":"trees list trees class phylo, multiPhylo object. tips Vector specifying four tips whose relationship reported, format accepted KeepTip().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/QuartetResolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relationship between four taxa — QuartetResolution","text":"vector specifying integer, tree, tips[-1] closely related tips[1].","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/QuartetResolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relationship between four taxa — QuartetResolution","text":"","code":"trees <- inapplicable.trees[[\"Vinther2008\"]] tips <- c(\"Lingula\", \"Halkieria\", \"Wiwaxia\", \"Acaenoplax\") QuartetResolution(trees, tips) #>  [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 3 2 3 3 2 1 3 3 3 2 3 2 2 2 #> [39] 3 3 2 2 1 2 3 2 1 1 2 1 3 2 3 3 2 1 1 1 3 1 2 1 2 1 3 3 2 1 2 1 2 2 3"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomMorphyTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Random postorder tree — RandomMorphyTree","title":"Random postorder tree — RandomMorphyTree","text":"Random postorder tree","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomMorphyTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random postorder tree — RandomMorphyTree","text":"","code":"RandomMorphyTree(nTip)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomMorphyTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random postorder tree — RandomMorphyTree","text":"nTip Integer specifying number tips include tree (minimum 2).","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomMorphyTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random postorder tree — RandomMorphyTree","text":"list three elements, vector integers, respectively containing: parent tip node, order left child node right child node.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomTreeScore.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsimony score of random postorder tree — RandomTreeScore","title":"Parsimony score of random postorder tree — RandomTreeScore","text":"Parsimony score random postorder tree","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomTreeScore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsimony score of random postorder tree — RandomTreeScore","text":"","code":"RandomTreeScore(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomTreeScore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsimony score of random postorder tree — RandomTreeScore","text":"morphyObj Object class morphy, perhaps created PhyDat2Morphy().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomTreeScore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parsimony score of random postorder tree — RandomTreeScore","text":"RandomTreeScore() returns parsimony score random tree given Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RandomTreeScore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parsimony score of random postorder tree — RandomTreeScore","text":"","code":"tokens <- matrix(c(   0, \"-\", \"-\", 1, 1, 2,   0, 1, 0, 1, 2, 2,   0, \"-\", \"-\", 0, 0, 0), byrow = TRUE, nrow = 3L,   dimnames = list(letters[1:3], NULL)) pd <- TreeTools::MatrixToPhyDat(tokens) morphyObj <- PhyDat2Morphy(pd)  RandomTreeScore(morphyObj) #> [1] 4  morphyObj <- UnloadMorphy(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsimony Ratchet — MorphyBootstrap","title":"Parsimony Ratchet — MorphyBootstrap","text":"Ratchet() uses parsimony ratchet Nixon1999TreeSearch search parsimonious tree using custom optimality criteria.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsimony Ratchet — MorphyBootstrap","text":"","code":"MorphyBootstrap(   edgeList,   morphyObj,   EdgeSwapper = NNISwap,   maxIter,   maxHits,   verbosity = 1L,   stopAtPeak = FALSE,   stopAtPlateau = 0L,   ... )  Ratchet(   tree,   dataset,   InitializeData = PhyDat2Morphy,   CleanUpData = UnloadMorphy,   TreeScorer = MorphyLength,   Bootstrapper = MorphyBootstrap,   swappers = list(TBRSwap, SPRSwap, NNISwap),   BootstrapSwapper = if (is.list(swappers)) swappers[[length(swappers)]] else swappers,   returnAll = FALSE,   stopAtScore = NULL,   stopAtPeak = FALSE,   stopAtPlateau = 0L,   ratchIter = 100,   ratchHits = 10,   searchIter = 4000,   searchHits = 42,   bootstrapIter = searchIter,   bootstrapHits = searchHits,   verbosity = 1L,   suboptimal = sqrt(.Machine[[\"double.eps\"]]),   ... )  MultiRatchet(   tree,   dataset,   ratchHits = 10,   searchIter = 500,   searchHits = 20,   verbosity = 0L,   swappers = list(RootedNNISwap),   nSearch = 10,   stopAtScore = NULL,   ... )  RatchetConsensus(   tree,   dataset,   ratchHits = 10,   searchIter = 500,   searchHits = 20,   verbosity = 0L,   swappers = list(RootedNNISwap),   nSearch = 10,   stopAtScore = NULL,   ... )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsimony Ratchet — MorphyBootstrap","text":"edgeList list containing following: vector integers corresponding parent edge turn vector integers corresponding child edge turn (optionally) score tree (optionally, score provided) number times score hit morphyObj Object class morphy, perhaps created PhyDat2Morphy(). EdgeSwapper function rearranges parent child vector, returns list modified vectors; example SPRSwap(). maxIter Numeric specifying maximum number iterations perform tree search. maxHits Numeric specifying maximum number hits accomplish tree search. verbosity Numeric specifying level detail display console: larger numbers provide verbose feedback user. stopAtPeak Logical specifying whether terminate search subsequent iteration recovers sub-optimal score. overridden passed function attribute stopAtPeak set attr(FunctionName, \"stopAtPeak\") <- TRUE. stopAtPlateau Integer. > 0, tree search terminate score improved stopAtPlateau iterations. overridden passed function attribute stopAtPlateau set attr(FunctionName, \"stopAtPlateau\") <- TRUE. ... arguments pass TreeScorer(), e.g. dataset = . tree tree class phylo. dataset dataset format required TreeScorer(). InitializeData Function sets data object prepare tree search. function passed dataset parameter. return value passed TreeScorer() CleanUpData(). CleanUpData Function destroy data object function exit. function passed value returned InitializeData(). TreeScorer function score given tree. function passed three parameters, corresponding parent child entries tree's edge list, dataset. Bootstrapper Function perform bootstrapped rearrangements tree. First arguments edgeList dataset, initialized using InitializeData(). return rearranged edgeList. swappers list functions use conduct edge rearrangement tree search. Provide functions like NNISwap shuffle root position, RootedTBRSwap position root retained. may wish use extreme swappers (TBR) early list, subtle rearranger (NNI) later list make incremental tinkerings almost-optimal tree found. BootstrapSwapper Function RootedNNISwap use rearrange trees within Bootstrapper(). returnAll Set TRUE report MPTs encountered search, perhaps analyse consensus. stopAtScore stop search soon score hit beaten. ratchIter Stop many ratchet iterations performed. ratchHits Stop many ratchet iterations found best score. searchIter Integer specifying maximum rearrangements perform bootstrap ratchet iteration. override value single swapper function, set e.g. attr(SwapperFunction, \"searchIter\") <- 99 searchHits Integer specifying maximum times hit best score terminating tree search within ratchet iteration. override value single swapper function, set e.g. attr(SwapperFunction, \"searchHits\") <- 99 bootstrapIter Integer specifying maximum rearrangements perform bootstrap iteration (default: searchIter). bootstrapHits Integer specifying maximum times hit best score bootstrap iteration (default: searchHits). suboptimal retain trees suboptimal score. Defaults small value counter rounding errors. nSearch Number Ratchet searches conduct (RatchetConsensus())","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parsimony Ratchet — MorphyBootstrap","text":"MorphyBootstrap() returns tree optimal random sampling original characters. Ratchet() returns tree modified parsimony ratchet iterations. MultiRatchet() returns list optimal trees produced nSearch ratchet searches, consensus tree can generated using ape::consensus() TreeTools::ConsensusWithout().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsimony Ratchet — MorphyBootstrap","text":"usage pointers, see vignette.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Parsimony Ratchet — MorphyBootstrap","text":"RatchetConsensus(): deprecated alias MultiRatchet()","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parsimony Ratchet — MorphyBootstrap","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Ratchet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parsimony Ratchet — MorphyBootstrap","text":"","code":"data(\"Lobo\", package = \"TreeTools\") njtree <- TreeTools::NJTree(Lobo.phy) # Increase value of ratchIter and searchHits to do a proper search quickResult <- Ratchet(njtree, Lobo.phy, ratchIter = 2, searchHits = 3) #> * Beginning Parsimony Ratchet, with initial score 231 #> Completed parsimony ratchet after 2 iterations with score 217  # Plot result (legibly) oldPar <- par(mar = rep(0, 4), cex = 0.75) plot(quickResult)  par(oldPar)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RearrangeEdges.html","id":null,"dir":"Reference","previous_headings":"","what":"Rearrange edges of a phylogenetic tree — RearrangeEdges","title":"Rearrange edges of a phylogenetic tree — RearrangeEdges","text":"RearrangeEdges() performs specified edge rearrangement matrix corresponds edges phylogenetic tree, returning score new tree. generally called within tree search function.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RearrangeEdges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rearrange edges of a phylogenetic tree — RearrangeEdges","text":"","code":"RearrangeEdges(   parent,   child,   dataset,   TreeScorer = MorphyLength,   EdgeSwapper,   scoreToBeat = TreeScorer(parent, child, dataset, ...),   iter = \"?\",   hits = 0L,   verbosity = 0L,   ... )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RearrangeEdges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rearrange edges of a phylogenetic tree — RearrangeEdges","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. dataset Third argument pass TreeScorer. TreeScorer function score given tree. function passed three parameters, corresponding parent child entries tree's edge list, dataset. EdgeSwapper function rearranges parent child vector, returns list modified vectors; example SPRSwap(). scoreToBeat Double giving score input tree. iter iteration number calling function, reporting user . hits Integer giving number times input tree already hit. verbosity Numeric specifying level detail display console: larger numbers provide verbose feedback user. ... arguments pass TreeScorer(), e.g. dataset = .","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RearrangeEdges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rearrange edges of a phylogenetic tree — RearrangeEdges","text":"function returns list two four elements, corresponding binary tree: - 1. Integer vector listing parent node edge; - 2. Integer vector listing child node edge; - 3. Score tree; - 4. Number times score hit.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RearrangeEdges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rearrange edges of a phylogenetic tree — RearrangeEdges","text":"RearrangeTree() performs one tree rearrangement specified type, returns score tree (given dataset). also reports number times score hit current function call.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RearrangeEdges.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rearrange edges of a phylogenetic tree — RearrangeEdges","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/RearrangeEdges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rearrange edges of a phylogenetic tree — RearrangeEdges","text":"","code":"data(\"Lobo\", package=\"TreeTools\") tree <- TreeTools::NJTree(Lobo.phy) edge <- tree$edge parent <- edge[, 1] child <- edge[, 2] dataset <- PhyDat2Morphy(Lobo.phy) RearrangeEdges(parent, child, dataset, EdgeSwapper = RootedNNISwap) #> [[1]] #>  [1] 49 49 50 50 51 52 53 54 55 56 56 55 57 58 58 59 60 60 59 57 61 62 62 61 63 #> [26] 64 64 63 65 66 66 67 68 68 67 69 70 70 69 71 71 65 72 73 74 75 75 74 73 76 #> [51] 76 72 54 53 77 77 78 79 79 78 80 81 82 82 81 80 83 83 84 85 86 86 85 87 87 #> [76] 84 52 88 88 51 89 90 91 92 92 91 93 93 94 94 95 95 90 89 #>  #> [[2]] #>  [1]  1 50  2 51 52 53 54 55 56  3  4 57 58  5 59 60 28 29 30 61 62 31 32 63 64 #> [26] 34 35 65 66 36 67 68 43 44 69 70 45 46 71 47 48 72 73 74 75 37 41 42 76 38 #> [51] 39 40  6 77  9 78 79 10 11 80 81 82 12 13 22 83 14 84 85 86 15 18 87 16 17 #> [76] 19 88  7  8 89 90 91 92 20 21 93 24 94 25 95 26 27 23 33 #>  #> [[3]] #> [1] 231 #>  #> [[4]] #> [1] 1 #>  # Remember to free memory: dataset <- UnloadMorphy(dataset)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":null,"dir":"Reference","previous_headings":"","what":"Subtree pruning and rearrangement (SPR) — SPR","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"Perform one SPR rearrangement tree","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"","code":"SPR(tree, edgeToBreak = NULL, mergeEdge = NULL)  SPRMoves(tree, edgeToBreak = integer(0))  # S3 method for class 'phylo' SPRMoves(tree, edgeToBreak = integer(0))  # S3 method for class 'matrix' SPRMoves(tree, edgeToBreak = integer(0))  SPRSwap(   parent,   child,   nEdge = length(parent),   nNode = nEdge/2L,   edgeToBreak = NULL,   mergeEdge = NULL )  RootedSPR(tree, edgeToBreak = NULL, mergeEdge = NULL)  RootedSPRSwap(   parent,   child,   nEdge = length(parent),   nNode = nEdge/2L,   edgeToBreak = NULL,   mergeEdge = NULL )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"tree tree class phylo. edgeToBreak index edge bisect, generated randomly specified. mergeEdge index edge merge broken edge. parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. nEdge (optional) integer specifying number edges tree class phylo, .e. dim(tree$edge)[1] nNode (optional) Number nodes.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"function returns tree phyDat format undergone one SPR iteration. TBRMoves() returns list trees one SPR move away tree, edges nodes preorder, rooted first-labelled tip. list containing two elements, corresponding turn rearranged parent child parameters list containing two elements, corresponding turn rearranged parent child parameters","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"Equivalent kSPR() phangorn package, faster. Note rearrangements change position root returned SPR.  position root irrelevant (Fitch parsimony, example) function occasionally return functionally equivalent topology. RootIrrelevantSPR search tree space efficiently cases. Branch lengths (yet) supported. nodes tree must bifurcating; ape::collapse.singles ape::multi2di may help.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"SPRSwap(): faster version takes returns parent child parameters RootedSPR(): Perform SPR rearrangement, retaining position root RootedSPRSwap(): faster version takes returns parent child parameters","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"SPR algorithm summarized Felsenstein2004TreeSearch","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SPR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subtree pruning and rearrangement (SPR) — SPR","text":"","code":"{ tree <- ape::rtree(20, br=FALSE) SPR(tree) } #>  #> Phylogenetic tree with 20 tips and 19 internal nodes. #>  #> Tip labels: #>   t12, t7, t19, t5, t6, t1, ... #>  #> Rooted; includes branch length(s)."},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SingleCharMorphy.html","id":null,"dir":"Reference","previous_headings":"","what":"Morphy object from single character — SingleCharMorphy","title":"Morphy object from single character — SingleCharMorphy","text":"Morphy object single character","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SingleCharMorphy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Morphy object from single character — SingleCharMorphy","text":"","code":"SingleCharMorphy(char, gap = \"inapp\")"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SingleCharMorphy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Morphy object from single character — SingleCharMorphy","text":"char State character tip turn, format converted character string paste0(char, \";\", collapse=\"\"). gap unambiguous abbreviation inapplicable, ambiguous (= missing), extra state, specifying gaps handled.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SingleCharMorphy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Morphy object from single character — SingleCharMorphy","text":"pointer object class morphyObj. forget unload finished .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SingleCharMorphy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Morphy object from single character — SingleCharMorphy","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SingleCharMorphy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Morphy object from single character — SingleCharMorphy","text":"","code":"morphyObj <- SingleCharMorphy(\"-0-0\", gap = \"Extra\") RandomTreeScore(morphyObj) #> [1] 2 morphyObj <- UnloadMorphy(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SiteConcordance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate site concordance factor — SiteConcordance","title":"Calculate site concordance factor — SiteConcordance","text":"site concordance factor Minh2020TreeSearch measure strength support dataset presents given split tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SiteConcordance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate site concordance factor — SiteConcordance","text":"","code":"QuartetConcordance(tree, dataset = NULL, weight = TRUE)  ClusteringConcordance(tree, dataset)  PhylogeneticConcordance(tree, dataset)  MutualClusteringConcordance(tree, dataset)  SharedPhylogeneticConcordance(tree, dataset)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SiteConcordance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate site concordance factor — SiteConcordance","text":"tree tree class phylo. dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadCharacters. weight Logical specifying whether weight sites according number quartets decisive .","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SiteConcordance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate site concordance factor — SiteConcordance","text":"QuartetConcordance() proportion quartets (sets four leaves) decisive split also concordant . example, quartet characters 0 0 0 1 decisive, relationships leaves equally parsimonious. quartet characters 0 0 1 1 decisive, concordant tree groups first two leaves together exclusion second. default, reported value weights site number quartets decisive .  value can interpreted proportion decisive quartets concordant split. weight = FALSE, reported value mean concordance value site. Consider split associated two sites: one concordant 25% 96 decisive quartets, second concordant 75% 4 decisive quartets. weight = TRUE, split concordance 24 + 3 / 96 + 4 = 27%. weight = FALSE, split concordance mean(75%, 25%) = 50%. QuartetConcordance() computed exactly, using quartets, implementations (e.g. IQ-TREE) follow @Minh2020;textualTreeSearch using random subsample quartets faster, potentially less accurate, computation. NOTE: functions development. incompletely tested, may change without notice. Complete documentation discussion follow due course.","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SiteConcordance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate site concordance factor — SiteConcordance","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SiteConcordance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate site concordance factor — SiteConcordance","text":"","code":"data(\"congreveLamsdellMatrices\", package = \"TreeSearch\") dataset <- congreveLamsdellMatrices[[1]][, 1:20] tree <- referenceTree qc <- QuartetConcordance(tree, dataset) cc <- ClusteringConcordance(tree, dataset) pc <- PhylogeneticConcordance(tree, dataset) spc <- SharedPhylogeneticConcordance(tree, dataset) mcc <- MutualClusteringConcordance(tree, dataset)  oPar <- par(mar = rep(0, 4), cex = 0.8) # Set plotting parameters plot(tree) TreeTools::LabelSplits(tree, signif(qc, 3), cex = 0.8)  plot(tree) TreeTools::LabelSplits(tree, signif(cc, 3), cex = 0.8)  par(oPar) # Restore plotting parameters  # Display correlation between concordance factors pairs(cbind(qc, cc, pc, spc, mcc), asp = 1)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StepInformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Information content of a character known to contain e steps — StepInformation","title":"Information content of a character known to contain e steps — StepInformation","text":"StepInformation() calculates phylogenetic information content character char e extra steps present, possible values e.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StepInformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Information content of a character known to contain e steps — StepInformation","text":"","code":"StepInformation(char, ambiguousTokens = c(\"-\", \"?\"))"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StepInformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Information content of a character known to contain e steps — StepInformation","text":"char Vector tokens listing states character question. ambiguousTokens Vector specifying tokens, , correspond ambiguous token (?).","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StepInformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Information content of a character known to contain e steps — StepInformation","text":"StepInformation() returns numeric vector detailing amount phylogenetic information (bits) associated character 0, 1, 2… extra steps present.  vector named total number steps associated entry vector: example, character three observed tokens must exhibit two steps, first entry (zero extra steps) named 2 (two steps observed).","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StepInformation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Information content of a character known to contain e steps — StepInformation","text":"Calculates number trees consistent character e extra steps, e ranges minimum possible value (.e. number different tokens minus one) maximum.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StepInformation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Information content of a character known to contain e steps — StepInformation","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StepInformation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Information content of a character known to contain e steps — StepInformation","text":"","code":"character <- rep(c(0:3, \"?\", \"-\"), c(8, 5, 1, 1, 2, 2)) StepInformation(character) #>         3         4         5         6         7  #> 9.9203529 5.5280354 2.5784492 0.7618403 0.0000000"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StopUnlessBifurcating.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that all nodes in a tree are bifurcating. — StopUnlessBifurcating","title":"Check that all nodes in a tree are bifurcating. — StopUnlessBifurcating","text":"Check nodes tree bifurcating.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StopUnlessBifurcating.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that all nodes in a tree are bifurcating. — StopUnlessBifurcating","text":"","code":"StopUnlessBifurcating(parent)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StopUnlessBifurcating.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that all nodes in a tree are bifurcating. — StopUnlessBifurcating","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1].","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StopUnlessBifurcating.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that all nodes in a tree are bifurcating. — StopUnlessBifurcating","text":"Returns NULL, stop error message tree appear bifurcating.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/StopUnlessBifurcating.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check that all nodes in a tree are bifurcating. — StopUnlessBifurcating","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Suboptimality.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree suboptimality — Suboptimality","title":"Tree suboptimality — Suboptimality","text":"suboptimal tree?","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Suboptimality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree suboptimality — Suboptimality","text":"","code":"Suboptimality(trees, proportional = FALSE)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Suboptimality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree suboptimality — Suboptimality","text":"trees list trees, include optimal tree proportional logical stating whether normalise results lowest score","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/Suboptimality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree suboptimality — Suboptimality","text":"Suboptimality() returns vector listing, tree, much score differs optimal (lowest) score.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SuccessiveApproximations.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree search using successive approximations — SuccessiveApproximations","title":"Tree search using successive approximations — SuccessiveApproximations","text":"Searches tree optimal Successive Approximations criterion Farris1969TreeSearch.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SuccessiveApproximations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree search using successive approximations — SuccessiveApproximations","text":"","code":"SuccessiveApproximations(   tree,   dataset,   outgroup = NULL,   k = 3,   maxSuccIter = 20,   ratchetHits = 100,   searchHits = 50,   searchIter = 500,   ratchetIter = 5000,   verbosity = 0,   suboptimal = 0.1 )  SuccessiveWeights(tree, dataset)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SuccessiveApproximations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree search using successive approximations — SuccessiveApproximations","text":"tree tree class phylo. dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. outgroup NULL, taxa tree rooted k Constant successive approximations, see Farris 1969 p. 379 maxSuccIter maximum iterations successive approximation ratchetHits maximum hits parsimony ratchet searchHits maximum hits tree search searchIter maximum iterations tree search ratchetIter maximum iterations parsimony ratchet verbosity Numeric specifying level detail display console: larger numbers provide verbose feedback user. suboptimal retain trees proportion less optimal optimal tree","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/SuccessiveApproximations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree search using successive approximations — SuccessiveApproximations","text":"SuccessiveApproximations() returns list class multiPhylo containing optimal (slightly suboptimal, suboptimal > 0) trees. SuccessiveWeights() returns score tree, given weighting instructions specified attributes dataset.","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree bisection and reconnection (TBR) — TBR","title":"Tree bisection and reconnection (TBR) — TBR","text":"TBR performs single random TBR iteration.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree bisection and reconnection (TBR) — TBR","text":"","code":"TBR(tree, edgeToBreak = NULL, mergeEdges = NULL)  TBRMoves(tree, edgeToBreak = integer(0))  # S3 method for class 'phylo' TBRMoves(tree, edgeToBreak = integer(0))  # S3 method for class 'matrix' TBRMoves(tree, edgeToBreak = integer(0))  TBRSwap(   parent,   child,   nEdge = length(parent),   edgeToBreak = NULL,   mergeEdges = NULL )  RootedTBR(tree, edgeToBreak = NULL, mergeEdges = NULL)  RootedTBRSwap(   parent,   child,   nEdge = length(parent),   edgeToBreak = NULL,   mergeEdges = NULL )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree bisection and reconnection (TBR) — TBR","text":"tree bifurcating tree class phylo, nodes resolved; edgeToBreak (optional) integer specifying index edge bisect/prune, generated randomly specified. Alternatively, set -1 return complete list trees one step input tree. mergeEdges (optional) vector length 1 2, listing edge(s) joined: SPR, pruned subtree reconnected. TBR, edges reconnected (must opposite sides edgeToBreak); single edge specified, second chosen random parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. nEdge (optional) Number edges.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree bisection and reconnection (TBR) — TBR","text":"TBR() returns tree phyDat format undergone one TBR iteration. TBRMoves() returns multiPhylo object listing trees one TBR move away tree, edges nodes preorder, rooted first-labelled tip. TBRSwap() returns list containing two elements corresponding rearranged parent child parameters.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tree bisection and reconnection (TBR) — TBR","text":"Branch lengths (yet) supported. nodes tree must bifurcating; ape::collapse.singles ape::multi2di may help.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Tree bisection and reconnection (TBR) — TBR","text":"TBRSwap(): faster version takes returns parent child parameters RootedTBR(): Perform TBR rearrangement, retaining position root RootedTBRSwap(): faster version takes returns parent child parameters","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Tree bisection and reconnection (TBR) — TBR","text":"TBR algorithm summarized Felsenstein2004TreeSearch","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tree bisection and reconnection (TBR) — TBR","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree bisection and reconnection (TBR) — TBR","text":"","code":"library(\"ape\") tree <- rtree(20, br=NULL) TBR(tree) #>  #> Phylogenetic tree with 20 tips and 19 internal nodes. #>  #> Tip labels: #>   t14, t15, t12, t18, t6, t19, ... #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBRWarning.html","id":null,"dir":"Reference","previous_headings":"","what":"TBR Warning Print a warning and return given tree — SPRWarning","title":"TBR Warning Print a warning and return given tree — SPRWarning","text":"TBR Warning Print warning return given tree","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBRWarning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TBR Warning Print a warning and return given tree — SPRWarning","text":"","code":"SPRWarning(parent, child, error)  TBRWarning(parent, child, error)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBRWarning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TBR Warning Print a warning and return given tree — SPRWarning","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. error error message report","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBRWarning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TBR Warning Print a warning and return given tree — SPRWarning","text":"list entries parent, child.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBRWarning.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"TBR Warning Print a warning and return given tree — SPRWarning","text":"SPRWarning(): SPR rearrangements","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBRWarning.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"TBR Warning Print a warning and return given tree — SPRWarning","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TBRWarning.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TBR Warning Print a warning and return given tree — SPRWarning","text":"","code":"suppressWarnings(TBRWarning(0, 0, \"Message text\")) # will trigger warning #> [[1]] #> [1] 0 #>  #> [[2]] #> [1] 0 #>"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"TaxonInfluence() ranks taxa according influence parsimonious topology.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"","code":"TaxonInfluence(   dataset,   tree = NULL,   Distance = ClusteringInfoDistance,   calcWeighted = TRUE,   savePath = NULL,   useCache = FALSE,   verbosity = 3L,   ... )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. tree Optimal tree summary tree (class \"phylo\") list trees (class \"list\" \"multiPhylo\") results evaluated. NULL, optimal tree sought using parsimony search parameters provided .... Distance Function calculate tree distance; default: ClusteringInfoDistance(). calcWeighted Logical specifying whether compute distance-weighted mean value. savePath Character giving prefix path reduced trees saved (write.nexus()). File names follow pattern paste0(savePath, droppedTaxonName, \".nex\"); savePath thus contain trailing / writing directory, created exist.  Special characters removed leaf labels creating file path (using path_sanitize()). NULL, computed trees saved. useCache Logical vector; TRUE, previous tree search results loaded location given savePath, instead running fresh search specified dataset parameters. verbosity, ... Parameters MaximizeParsimony(). Tree search conducted using tree starting tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"TaxonInfluence() returns matrix listing phylogenetic influence taxon, measured units chosen tree distance metric (default = bits). Columns denote taxa; rows denote maximum, distance-weighted mean, minimum distance optimal tree sets.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"TaxonInfluence() follows approach Mariadassou2012sb;textualTreeSearch repeating tree search whilst leaving taxon turn analysis, measuring distance reconstructed trees optimal tree obtained taxa included phylogenetic inference. Denton2018ee;textualTreeSearch emphasize, Robinson–Foulds distance unsuitable purpose; function allows user specify preferred tree distance measure, defaulting clustering information distance Smith2020TreeSearch. optimal parsimony trees equiprobable, taxon influence ranked based maximum minimum tree--tree distances optimal trees.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":"distance-weighted-mean","dir":"Reference","previous_headings":"","what":"Distance-weighted mean","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"Sets equally parsimonious trees statistical samples tree space, biased towards areas uncertainty. possible set trees contains possible resolutions particular clade, single topology clade exist – essentially two distinct solutions, one () summarised summary tree contains polytomy, another (b) summarized perfectly resolved tree. Neither scenarios preferable principles parsimony; summary statistics (e.g. mean, median) strongly influenced many trees group , thus underplaying existence solution b. TaxonInfluence() uses ad hoc method produce summary statistics weighting trees' distance trees.  Trees close neighbours contribute weighted mean, thus reducing influence many trees differ small details. distance-weighted mean thus less prone bias simple mean – statistically valid, (potentially) provides representative summary comparisons sets trees.","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TaxonInfluence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rank taxa by their influence on phylogenetic results — TaxonInfluence","text":"","code":"#' # Load data for analysis in R library(\"TreeTools\") data(\"congreveLamsdellMatrices\", package = \"TreeSearch\")  # Small dataset for demonstration purposes dataset <- congreveLamsdellMatrices[[42]][1:8, ] bestTree <- MaximizeParsimony(dataset, verbosity = 0)[[1]]  # Calculate tip influence influence <- TaxonInfluence(dataset, ratchIt = 0, startIt = 0, verbos = 0) #>  #> ── BEGIN TREE SEARCH (k = Inf) ───────────────────────────────────────────────── #> → Initial score: 86  #>  #> ── Sample local optimum ──────────────────────────────────────────────────────── #> → TBR depth 2; keeping 14.4 trees; k = Inf #> ℹ 2025-04-04 14:51:29: Score: 86 #> ✔ 2025-04-04 14:51:29: Tree search terminated with score 82  # Colour tip labels according to their influence upperBound <- 2 * TreeDist::ClusteringEntropy(   PectinateTree(NTip(dataset) - 1)) nBin <- 128 bin <- cut(   influence[\"max\", ],   breaks = seq(0, upperBound, length.out = nBin),   include.lowest = TRUE ) palette <- hcl.colors(nBin, \"inferno\")  plot(bestTree, tip.color = palette[bin]) PlotTools::SpectrumLegend(   \"bottomleft\",   palette = palette,   title = \"Tip influence / bits\",   legend = signif(seq(upperBound, 0, length.out = 4), 3),   bty = \"n\" )"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the parsimony score of a tree given a dataset — IWScore","title":"Calculate the parsimony score of a tree given a dataset — IWScore","text":"TreeLength() uses Morphy library Brazeau2017TreeSearch calculate parsimony score tree, handling inapplicable data according algorithm Brazeau2019;textualTreeSearch. Trees may scored using equal weights, implied weights Goloboff1993TreeSearch, profile parsimony Faith2001TreeSearch.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the parsimony score of a tree given a dataset — IWScore","text":"","code":"IWScore(tree, dataset, concavity = 10L, ...)  TreeLength(tree, dataset, concavity = Inf)  # S3 method for class 'phylo' TreeLength(tree, dataset, concavity = Inf)  # S3 method for class 'numeric' TreeLength(tree, dataset, concavity = Inf)  # S3 method for class 'list' TreeLength(tree, dataset, concavity = Inf)  # S3 method for class 'multiPhylo' TreeLength(tree, dataset, concavity = Inf)  Fitch(tree, dataset)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the parsimony score of a tree given a dataset — IWScore","text":"tree tree class phylo, list thereof (optionally class multiPhylo), integer – case tree random trees uniformly sampled. dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. concavity Determines degree extra steps beyond first penalized.  Specify numeric value use implied weighting Goloboff1993TreeSearch; concavity specifies k k / e + k. value 10 recommended; TNT sets default 3, low circumstances Goloboff2018,Smith2019TreeSearch. Better still explore sensitivity results range concavity values, e.g. k = 2 ^ (1:7). Specify Inf weight additional step equally. Specify \"profile\" employ profile parsimony Faith2001TreeSearch. ... unused; allows additional parameters specified within ... received function without throwing error.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the parsimony score of a tree given a dataset — IWScore","text":"TreeLength() returns numeric vector containing score tree tree.","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeLength.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate the parsimony score of a tree given a dataset — IWScore","text":"Martin R. Smith (using Morphy C library, Martin Brazeau)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeLength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the parsimony score of a tree given a dataset — IWScore","text":"","code":"data(\"inapplicable.datasets\") tree <- TreeTools::BalancedTree(inapplicable.phyData[[1]]) TreeLength(tree, inapplicable.phyData[[1]]) #> [1] 1117 TreeLength(tree, inapplicable.phyData[[1]], concavity = 10) #> [1] 52.75785 TreeLength(tree, inapplicable.phyData[[1]], concavity = \"profile\") #> → Inapplicable tokens treated as ambiguous for profile parsimony #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> Warning: Can handle max. 2 informative tokens. Dropping others. #> [1] 3941.387 TreeLength(5, inapplicable.phyData[[1]]) #> [1] 1974 1985 1907 1948 1926"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeSearch.html","id":null,"dir":"Reference","previous_headings":"","what":"Search for most parsimonious trees — EdgeListSearch","title":"Search for most parsimonious trees — EdgeListSearch","text":"Run standard search algorithms (NNI, SPR TBR) search parsimonious tree. detailed documentation \"TreeSearch\" package, including full instructions loading phylogenetic data R initiating configuring tree search, see package documentation.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeSearch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search for most parsimonious trees — EdgeListSearch","text":"","code":"EdgeListSearch(   edgeList,   dataset,   TreeScorer = MorphyLength,   EdgeSwapper = RootedTBRSwap,   maxIter = 100,   maxHits = 20,   bestScore = NULL,   stopAtScore = NULL,   stopAtPeak = FALSE,   stopAtPlateau = 0L,   verbosity = 1L,   ... )  TreeSearch(   tree,   dataset,   InitializeData = PhyDat2Morphy,   CleanUpData = UnloadMorphy,   TreeScorer = MorphyLength,   EdgeSwapper = RootedTBRSwap,   maxIter = 100L,   maxHits = 20L,   stopAtPeak = FALSE,   stopAtPlateau = 0L,   verbosity = 1L,   ... )  IWTreeSearch(...)  EmptyPhyDat(tree)  DoNothing(...)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeSearch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search for most parsimonious trees — EdgeListSearch","text":"edgeList list containing following: vector integers corresponding parent edge turn vector integers corresponding child edge turn (optionally) score tree (optionally, score provided) number times score hit dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. Perhaps load R using ReadAsPhyDat. TreeScorer function score given tree. function passed three parameters, corresponding parent child entries tree's edge list, dataset. EdgeSwapper function rearranges parent child vector, returns list modified vectors; example SPRSwap(). maxIter Numeric specifying maximum number iterations perform abandoning search. maxHits Numeric specifying maximum times hit best pscore abandoning search. stopAtPeak Logical specifying whether terminate search subsequent iteration recovers sub-optimal score. overridden passed function attribute stopAtPeak set attr(FunctionName, \"stopAtPeak\") <- TRUE. stopAtPlateau Integer. > 0, tree search terminate score improved stopAtPlateau iterations. overridden passed function attribute stopAtPlateau set attr(FunctionName, \"stopAtPlateau\") <- TRUE. verbosity Numeric specifying level detail display console: larger numbers provide verbose feedback user. ... arguments pass TreeScorer(), e.g. dataset = . tree fully-resolved starting tree phylo format, desired outgroup. Edge lengths supported removed. InitializeData Function sets data object prepare tree search. function passed dataset parameter. return value passed TreeScorer() CleanUpData(). CleanUpData Function destroy data object function exit. function passed value returned InitializeData().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeSearch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search for most parsimonious trees — EdgeListSearch","text":"TreeSearch() returns tree, attribute pscore conveying parsimony score. #\" Note parsimony score inherited tree\"s attributes, valid generated using data passed . EmptyPhyDat() returns phyDat object comprising single null character, coded state zero every leaf tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeSearch.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Search for most parsimonious trees — EdgeListSearch","text":"EdgeListSearch(): Tree search edge lists","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeSearch.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Search for most parsimonious trees — EdgeListSearch","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/TreeSearch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search for most parsimonious trees — EdgeListSearch","text":"","code":"data(\"Lobo\", package=\"TreeTools\") njtree <- TreeTools::NJTree(Lobo.phy)  ## Only run examples in interactive R sessions if (interactive()) {   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = NNISwap)   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = RootedSPRSwap)   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = TBRSwap) }"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/UnloadMorphy.html","id":null,"dir":"Reference","previous_headings":"","what":"Destroy a Morphy object — UnloadMorphy","title":"Destroy a Morphy object — UnloadMorphy","text":"Destroys previously-created Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/UnloadMorphy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Destroy a Morphy object — UnloadMorphy","text":"","code":"UnloadMorphy(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/UnloadMorphy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Destroy a Morphy object — UnloadMorphy","text":"morphyObj Object class morphy, perhaps created PhyDat2Morphy().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/UnloadMorphy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Destroy a Morphy object — UnloadMorphy","text":"Morphy error code, decipherable using mpl_translate_error","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/UnloadMorphy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Destroy a Morphy object — UnloadMorphy","text":"Best practice call morphyObj <- UnloadMorphy(morphyObj) Failure cause crash UnloadMorphy() called object  already destroyed","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/UnloadMorphy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Destroy a Morphy object — UnloadMorphy","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WhenFirstHit.html","id":null,"dir":"Reference","previous_headings":"","what":"When was a tree topology first hit? — WhenFirstHit","title":"When was a tree topology first hit? — WhenFirstHit","text":"Reports tree list first found tree search. information read firstHit attribute present. , trees taken listed order found, named according search iteration first hit - situation trees found MaximizeParsimony() saved file.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WhenFirstHit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"When was a tree topology first hit? — WhenFirstHit","text":"","code":"WhenFirstHit(trees)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WhenFirstHit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"When was a tree topology first hit? — WhenFirstHit","text":"trees list trees, multiPhylo object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WhenFirstHit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"When was a tree topology first hit? — WhenFirstHit","text":"trees, firstHit attribute listing number trees hit first time search iteration.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WhenFirstHit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"When was a tree topology first hit? — WhenFirstHit","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WhenFirstHit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"When was a tree topology first hit? — WhenFirstHit","text":"","code":"library(\"TreeTools\", quietly = TRUE) trees <- list(    seed_00 = as.phylo(1, 8),    ratch1_01 = as.phylo(2, 8),    ratch1_02 = as.phylo(3, 8),    ratch4_44 = as.phylo(4, 8),    final_99 = as.phylo(5, 8) ) attr(WhenFirstHit(trees), \"firstHit\") #> whenHit #>   seed ratch1 ratch4  final  #>      1      2      1      1"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WithOneExtraStep.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of trees with one extra step — WithOneExtraStep","title":"Number of trees with one extra step — WithOneExtraStep","text":"Number trees one extra step","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WithOneExtraStep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of trees with one extra step — WithOneExtraStep","text":"","code":"WithOneExtraStep(...)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WithOneExtraStep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of trees with one extra step — WithOneExtraStep","text":"... Vector series integers specifying number leaves bearing distinct non-ambiguous token.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/WithOneExtraStep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of trees with one extra step — WithOneExtraStep","text":"","code":"WithOneExtraStep(1, 2, 3) #> [1] 84"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/cSPR.html","id":null,"dir":"Reference","previous_headings":"","what":"cSPR() expects a tree rooted on a single tip. — cSPR","title":"cSPR() expects a tree rooted on a single tip. — cSPR","text":"cSPR() expects tree rooted single tip.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/cSPR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"cSPR() expects a tree rooted on a single tip. — cSPR","text":"","code":"cSPR(tree, whichMove = NULL)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/cSPR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"cSPR() expects a tree rooted on a single tip. — cSPR","text":"tree tree class phylo. whichMove Integer specifying SPR move index perform.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/cSPR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"cSPR() expects a tree rooted on a single tip. — cSPR","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/cSPR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"cSPR() expects a tree rooted on a single tip. — cSPR","text":"","code":"tree <- TreeTools::BalancedTree(8)  # Tree must be rooted on leaf tree <- TreeTools::RootTree(tree, 1)  # Random rearrangement cSPR(tree) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length.  # Specific rearrangement cSPR(tree, 9) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeSearch/dev/reference/congreveLamsdellMatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"100 simulated data matrices — congreveLamsdellMatrices","title":"100 simulated data matrices — congreveLamsdellMatrices","text":"Contains 100 simulated matrices generated Congreve2016TreeSearch using heterogeneous Markov-k model, generated referenceTree topology, branches sharing equal length.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/congreveLamsdellMatrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"100 simulated data matrices — congreveLamsdellMatrices","text":"","code":"congreveLamsdellMatrices"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/congreveLamsdellMatrices.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"100 simulated data matrices — congreveLamsdellMatrices","text":"list 100 entries, comprising phyDat object 55 characters 22 taxa","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/congreveLamsdellMatrices.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"100 simulated data matrices — congreveLamsdellMatrices","text":"doi:10.5061/dryad.7dq0j","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/congreveLamsdellMatrices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"100 simulated data matrices — congreveLamsdellMatrices","text":"","code":"data(\"referenceTree\") data(\"congreveLamsdellMatrices\") TreeLength(referenceTree, congreveLamsdellMatrices[[17]], \"profile\") #> [1] 549.6488"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-CombineResults.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine two edge matrices — .CombineResults","title":"Combine two edge matrices — .CombineResults","text":"Combine two edge matrices","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-CombineResults.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine two edge matrices — .CombineResults","text":"","code":".CombineResults(x, y, stage)  .ReplaceResults(old, new, stage)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-CombineResults.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine two edge matrices — .CombineResults","text":"x, y 3D arrays, slice containing edge matrix tree class phylo.  x contain duplicates. stage Integer specifying element firstHit new hits recorded. old old array edge matrices firstHit attribute. new new array edge matrices.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-CombineResults.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine two edge matrices — .CombineResults","text":"single 3D array containing unique edge matrix (x ) y, firstHit attribute documented MaximizeParsimony().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-CombineResults.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine two edge matrices — .CombineResults","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-GapHandler.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate a gap treatment into a string in the format expected by Morphy — .GapHandler","title":"Translate a gap treatment into a string in the format expected by Morphy — .GapHandler","text":"Translate gap treatment string format expected Morphy","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-GapHandler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate a gap treatment into a string in the format expected by Morphy — .GapHandler","text":"","code":".GapHandler(gap)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-GapHandler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate a gap treatment into a string in the format expected by Morphy — .GapHandler","text":"gap Character vector: gaps handled?","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-GapHandler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate a gap treatment into a string in the format expected by Morphy — .GapHandler","text":"Character string can translated gap handling strategy Morphy.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-NonDuplicateRoot.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-duplicate root — .NonDuplicateRoot","title":"Non-duplicate root — .NonDuplicateRoot","text":"Identify, edge, whether denotes different partition root edge. first edge input tree must root edge; can accomplished using Preorder().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-NonDuplicateRoot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-duplicate root — .NonDuplicateRoot","text":"","code":".NonDuplicateRoot(parent, child, nEdge = length(parent))"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-NonDuplicateRoot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-duplicate root — .NonDuplicateRoot","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree$edge[, 1]. child Integer vector corresponding second column edge matrix tree class phylo, .e. tree$edge[, 2]. nEdge (optional) integer specifying number edges tree class phylo, .e. dim(tree$edge)[1]","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-NonDuplicateRoot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-duplicate root — .NonDuplicateRoot","text":".NonDuplicateRoot() returns logical vector length nEdge, specifying TRUE unless edge identifies partition root edge.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-NonDuplicateRoot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-duplicate root — .NonDuplicateRoot","text":"function copy deprecated ancestor TreeTools; see #32.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-NonDuplicateRoot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-duplicate root — .NonDuplicateRoot","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-NonDuplicateRoot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-duplicate root — .NonDuplicateRoot","text":"","code":"tree <- TreeTools::Preorder(TreeTools::BalancedTree(8)) edge <- tree$edge parent <- edge[, 1] child <- edge[, 2]  which(!.NonDuplicateRoot(parent, child)) #> [1] 1"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-UniqueExceptHits.html","id":null,"dir":"Reference","previous_headings":"","what":"Unique trees (ignoring ","title":"Unique trees (ignoring ","text":"Unique trees (ignoring \"hits\" attribute)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-UniqueExceptHits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unique trees (ignoring ","text":"","code":".UniqueExceptHits(trees)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/dot-UniqueExceptHits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Unique trees (ignoring ","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/inapplicable.datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Thirty datasets with inapplicable data — inapplicable.datasets","title":"Thirty datasets with inapplicable data — inapplicable.datasets","text":"datasets used evaluate behaviour inapplicable algorithm Brazeau2018;textualTreeTools. name item corresponds datasets listed . Datasets sorted two subsets, sorted alphabetically; first subset comprise simpler datasets faster processing times. inapplicable.datasets provide data matrix format generated read.nexus.data(); inapplicable.phyData phyDat format. inapplicable.trees lists dataset sample 50 trees obtained tree search inapplicable treatment, named accordingly. inapplicable.citations named character vector specifying source dataset.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/inapplicable.datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thirty datasets with inapplicable data — inapplicable.datasets","text":"","code":"inapplicable.datasets  inapplicable.phyData  inapplicable.trees  inapplicable.citations"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/inapplicable.datasets.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Thirty datasets with inapplicable data — inapplicable.datasets","text":"object class list length 30. object class list length 30. object class list length 31. object class character length 30.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/inapplicable.datasets.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Thirty datasets with inapplicable data — inapplicable.datasets","text":"Subset one (faster processing): Agnarsson2004 AGNARSSON, . 2004. Morphological phylogeny cobweb spiders relatives (Araneae, Araneoidea, Theridiidae). Zoological Journal Linnean Society, 141, 447–626. Capa2011 CAPA, M., HUTCHINGS, P., AGUADO, M. T. BOTT, N. J. 2011. Phylogeny Sabellidae (Annelida) relationships taxa inferred morphology multiple genes. Cladistics, 27, 449–469. DeAssis2011 DE ASSIS, J. E. CHRISTOFFERSEN, M. L. 2011. Phylogenetic relationships within Maldanidae (Capitellida, Annelida), based morphological characters. Systematics Biodiversity, 9, 233–245. OLeary1999 O'LEARY, M. . GEISLER, J. H. 1999. position Cetacea within Mammalia: phylogenetic analysis morphological data extinct extant taxa. Systematic Biology, 48, 455–490. Rousset2004 ROUSSET, V., ROUSE, G. W., SIDDALL, M. E., TILLIER, . PLEIJEL, F. 2004. phylogenetic position Siboglinidae (Annelida) inferred 18S rRNA, 28S rRNA morphological data. Cladistics, 20, 518–533. Sano2011 SANO, M. AKIMOTO, S.-. 2011. Morphological phylogeny gall-forming aphids tribe Eriosomatini (Aphididae: Eriosomatinae). Systematic Entomology, 36, 607–627. Sansom2010 SANSOM, R. S., FREEDMAN, K., GABBOTT, S. E., ALDRIDGE, R. J. PURNELL, M. . 2010. Taphonomy affinity enigmatic Silurian vertebrate, Jamoytius kerwoodi White. Palaeontology, 53, 1393–1409. Schulze2007 SCHULZE, ., CUTLER, E. B. GIRIBET, G. 2007. Phylogeny sipunculan worms: combined analysis four gene regions morphology. Molecular Phylogenetics Evolution, 42, 171–92. Shultz2007 SHULTZ, J. W. 2007. phylogenetic analysis arachnid orders based morphological characters. Zoological Journal Linnean Society, 150, 221–265. Wetterer2000 WETTERER, . L., ROCKKMAN, M. V. SIMMONS, N. B. 2000. Phylogeny phyllostomid bats (Mammalia: Chiroptera): data diverse morphological systems, sex chromosomes, restriction sites. Bulletin American Museum Natural History, 248, 1–200. Wills2012 WILLS, M. ., GERBER, S., RUTA, M. HUGHES, M. 2012. disparity priapulid, archaeopriapulid palaeoscolecid worms light new data. Journal Evolutionary Biology, 25, 2056–2076. Aguado2009 AGUADO, M. T. SAN MARTIN, G. 2009. Phylogeny Syllidae (Polychaeta) based morphological data. Zoologica Scripta, 38, 379–402. Aria2015 ARIA, C., CARON, J. B. GAINES, R. 2015. large new leanchoiliid Burgess Shale influence inapplicable states stem arthropod phylogeny. Palaeontology, 58, 629–660. Asher2005 ASHER, R. J. HOFREITER, M. 2006. Tenrec phylogeny noninvasive extraction nuclear DNA. Systematic biology, 55, 181–94. Baker2009 BAKER, W. J., SAVOLAINEN, V., ASMUSSEN-LANGE, C. B., CHASE, M. W., DRANSFIELD, J., FOREST, F., HARLEY, M. M., UHL, N. W. WILKINSON, M. 2009. Complete generic-level phylogenetic analyses palms (Arecaceae) comparisons supertree supermatrix approaches. Systematic Biology, 58, 240–256. Bouchenak2010 BOUCHENAK-KHELLADI, Y., VERBOOM, G. ., SAVOLAINEN, V. HODKINSON, T. R. 2010. Biogeography grasses (Poaceae): phylogenetic approach reveal evolutionary history geographical space geological time. Botanical Journal Linnean Society, 162, 543–557. Conrad2008 CONRAD, J. L. 2008. Phylogeny Systematics Squamata (Reptilia) Based Morphology. Bulletin American Museum Natural History, 310, 1–182. Dikow2009 DIKOW, T. 2009. phylogenetic hypothesis Asilidae based total evidence analysis morphological DNA sequence data (Insecta: Diptera: Brachycera: Asiloidea). Organisms Diversity Evolution, 9, 165–188. Eklund2004 EKLUND, H., DOYLE, J. . HERENDEEN, P. S. 2004. Morphological phylogenetic analysis living fossil Chloranthaceae. International Journal Plant Sciences, 165, 107–151. Geisler2001 GEISLER, J. H. 2001. New morphological evidence phylogeny Artiodactyla, Cetacea, Mesonychidae. American Museum Novitates, 3344, 53. Giles2015 GILES, S., FRIEDMAN, M. BRAZEAU, M. D. 2015. Osteichthyan-like cranial conditions Early Devonian stem gnathostome. Nature, 520, 82–85. Griswold1999 GRISWOLD, C. E., CODDINGTON, J. ., PLATNICK, N. . FORSTER, R. R. 1999. Towards phylogeny entelegyne spiders (Araneae, Araneomorphae, Entelegynae). Journal Arachnology, 27, 53–63. Liljeblad2008 LILJEBLAD, J., RONQUIST, F., NIEVES-ALDREY, J. L., FONTAL-CAZALLA, F., ROS-FARRE, P., GAITROS, D. PUJADE-VILLAR, J. 2008. fully web-illustrated morphological phylogenetic study relationships among oak gall wasps closest relatives (Hymenoptera: Cynipidae). Loconte1991 LOCONTE, H. STEVENSON, D. W. 1991. Cladistics Magnoliidae. Cladistics, 7, 267–296. Longrich2010 LONGRICH, N. R., SANKEY, J. TANKE, D. 2010. Texacephale langstoni, new genus pachycephalosaurid (Dinosauria: Ornithischia) upper Campanian Aguja Formation, southern Texas, USA. Cretaceous Research, 31, 274–284. OMeara2014 O'MEARA, R. N. THOMPSON, R. S. 2014. Miocene Meridiolestidans? Assessing phylogenetic placement Necrolestes patagonensis presence 40 million year Meridiolestidan ghost lineage. Journal Mammalian Evolution, 21, 271–284. Rougier2012 ROUGIER, G. W., WIBLE, J. R., BECK, R. M. D. APESTEGUIA, S. 2012. Miocene mammal Necrolestes demonstrates survival Mesozoic nontherian lineage late Cenozoic South America. Proceedings National Academy Sciences, 109, 20053–8. Sharkey2011 SHARKEY, M. J., CARPENTER, J. M., VILHELMSEN, L., HERATY, J., LILJEBLAD, J., DOWLING, . P. G., SCHULMEISTER, S., MURRAY, D., DEANS, . R., RONQUIST, F., KROGMANN, L. WHEELER, W. C. 2012. Phylogenetic relationships among superfamilies Hymenoptera. Cladistics, 28, 80–112. Sundue2010 SUNDUE, M. ., ISLAM, M. B. RANKER, T. . 2010. Systematics Grammitid Ferns (Polypodiaceae): Using Morphology Plastid Sequence Data Resolve Circumscriptions Melpomene Polyphyletic Genera Lellingeria Terpsichore. Systematic Botany, 35, 701–715. Vinther2008 VINTHER, J., VAN ROY, P. BRIGGS, D. E. G. 2008. Machaeridians Palaeozoic armoured annelids. Nature, 451, 185–188. Wilson2003 WILSON, G. D. F. EDGECOMBE, G. D. 2003. Triassic isopod Protamphisopus wianamattensis (Chilton) comparison extant taxa (Crustacea, Phreatoicidea). Journal Paleontology, 77, 454–470. Wortley2006 WORTLEY, . H. SCOTLAND, R. W. 2006. effect combining molecular morphological data published phylogenetic analyses. Systematic Biology, 55, 677–685. Zanol2014 ZANOL, J., HALANYCH, K. M. FAUCHALD, K. 2014. Reconciling taxonomy phylogeny bristleworm family Eunicidae (Polychaete, Annelida). Zoologica Scripta, 43, 79–100. Zhu2013 ZHU, M., YU, X., AHLBERG, P. E., CHOO, B., LU, J., QIAO, T., QU, Q., ZHAO, W., JIA, L., BLOM, H. ZHU, Y. 2013. Silurian placoderm osteichthyan-like marginal jaw bones. Nature, 502, 188–193.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/inapplicable.datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Thirty datasets with inapplicable data — inapplicable.datasets","text":"","code":"data(\"inapplicable.datasets\", package = \"TreeSearch\") names(inapplicable.datasets) #>  [1] \"Agnarsson2004\" \"Aguado2009\"    \"Aria2015\"      \"Asher2005\"     #>  [5] \"Capa2011\"      \"Conrad2008\"    \"DeAssis2011\"   \"Dikow2009\"     #>  [9] \"Eklund2004\"    \"Geisler2001\"   \"Giles2015\"     \"Griswold1999\"  #> [13] \"Liljeblad2008\" \"Loconte1991\"   \"Longrich2010\"  \"OLeary1999\"    #> [17] \"OMeara2014\"    \"Rougier2012\"   \"Rousset2004\"   \"Sano2011\"      #> [21] \"Sansom2010\"    \"Schulze2007\"   \"Shultz2007\"    \"Vinther2008\"   #> [25] \"Wetterer2000\"  \"Wills2012\"     \"Wilson2003\"    \"Wortley2006\"   #> [29] \"Zanol2014\"     \"Zhu2013\""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/is.morphyPtr.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object a valid Morphy object? — is.morphyPtr","title":"Is an object a valid Morphy object? — is.morphyPtr","text":"object valid Morphy object?","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/is.morphyPtr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object a valid Morphy object? — is.morphyPtr","text":"","code":"is.morphyPtr(morphyObj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/is.morphyPtr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object a valid Morphy object? — is.morphyPtr","text":"morphyObj Object class morphy, perhaps created PhyDat2Morphy().","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/is.morphyPtr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is an object a valid Morphy object? — is.morphyPtr","text":".morphyPtr() returns TRUE morphyObj valid morphy pointer, FALSE otherwise.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/is.morphyPtr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Is an object a valid Morphy object? — is.morphyPtr","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_apply_tipdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Commits parameters prior to nodal set calculations. — mpl_apply_tipdata","title":"Commits parameters prior to nodal set calculations. — mpl_apply_tipdata","text":"caller satisfied setup types, weights, partitioning, function must called, thereby committing parameters changes made. character types assigned, function fail error code.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_apply_tipdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Commits parameters prior to nodal set calculations. — mpl_apply_tipdata","text":"","code":"mpl_apply_tipdata(morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_apply_tipdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Commits parameters prior to nodal set calculations. — mpl_apply_tipdata","text":"morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_apply_tipdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Commits parameters prior to nodal set calculations. — mpl_apply_tipdata","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_apply_tipdata.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Commits parameters prior to nodal set calculations. — mpl_apply_tipdata","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_rawdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach raw character state data (i.e. tip data). — mpl_attach_rawdata","title":"Attach raw character state data (i.e. tip data). — mpl_attach_rawdata","text":"Attaches raw data character state matrix form C-style (.e. NULL-terminated) string. can matrix block extracted Nexus file xread table format. matrix contain leaf labels.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_rawdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach raw character state data (i.e. tip data). — mpl_attach_rawdata","text":"","code":"mpl_attach_rawdata(rawdata, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_rawdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach raw character state data (i.e. tip data). — mpl_attach_rawdata","text":"rawdata C-style string corresponding tip data taxon turn. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_rawdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach raw character state data (i.e. tip data). — mpl_attach_rawdata","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_rawdata.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Attach raw character state data (i.e. tip data). — mpl_attach_rawdata","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_symbols.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach a caller-specified list of symbols. — mpl_attach_symbols","title":"Attach a caller-specified list of symbols. — mpl_attach_symbols","text":"Allows caller specify list symbols data matrix, otherwise, symbols list used Morphy extracted matrix. symbols list must match symbols provided matrix. Morphy extracts symbols matrix, ordering alphanumeric, according ASCII codes (.e. \"+0123...ABCD...abcd...\"). Loading user-specified symbols list override ordering. Symbols loaded either list matrix must valid Morphy character state symbols defined statedata.h header file.  list must end semicolon.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_symbols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach a caller-specified list of symbols. — mpl_attach_symbols","text":"","code":"mpl_attach_symbols(symbols, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_symbols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach a caller-specified list of symbols. — mpl_attach_symbols","text":"symbols C-style (.e. NULL-terminated) string valid state symbols. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_symbols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach a caller-specified list of symbols. — mpl_attach_symbols","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_attach_symbols.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Attach a caller-specified list of symbols. — mpl_attach_symbols","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_Morphy.html","id":null,"dir":"Reference","previous_headings":"","what":"Destroys an instance of a Morphy object. — mpl_delete_Morphy","title":"Destroys an instance of a Morphy object. — mpl_delete_Morphy","text":"Destroys instance Morphy object, calling destructor internal object completely returning memory system.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_Morphy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Destroys an instance of a Morphy object. — mpl_delete_Morphy","text":"","code":"mpl_delete_Morphy(morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_Morphy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Destroys an instance of a Morphy object. — mpl_delete_Morphy","text":"morphyobj Morphy object destroyed.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_Morphy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Destroys an instance of a Morphy object. — mpl_delete_Morphy","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_Morphy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Destroys an instance of a Morphy object. — mpl_delete_Morphy","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_rawdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Deletes the caller-input data. — mpl_delete_rawdata","title":"Deletes the caller-input data. — mpl_delete_rawdata","text":"Deletes user-input data restores parameters original values, except dimensions matrix.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_rawdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deletes the caller-input data. — mpl_delete_rawdata","text":"","code":"mpl_delete_rawdata(morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_rawdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deletes the caller-input data. — mpl_delete_rawdata","text":"morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_rawdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deletes the caller-input data. — mpl_delete_rawdata","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_delete_rawdata.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Deletes the caller-input data. — mpl_delete_rawdata","text":"Thomas Guillerme","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_down_recon.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstructs the first (downpass) nodal reconstructions — mpl_first_down_recon","title":"Reconstructs the first (downpass) nodal reconstructions — mpl_first_down_recon","text":"Reconstructs preliminary nodal set characters particular node. function called postorder sequence internal nodes left right descendants known. function needs fairly high-performance, much checking parameter validity, thus unsafe usage function might caught. calling functions ensure appropriate parameters set use.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_down_recon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstructs the first (downpass) nodal reconstructions — mpl_first_down_recon","text":"","code":"mpl_first_down_recon(node_id, left_id, right_id, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_down_recon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstructs the first (downpass) nodal reconstructions — mpl_first_down_recon","text":"node_id index node reconstructed. left_id index left descendant. right_id index right descendant. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_down_recon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstructs the first (downpass) nodal reconstructions — mpl_first_down_recon","text":"integral parsimony length (right now)","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_down_recon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reconstructs the first (downpass) nodal reconstructions — mpl_first_down_recon","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_up_recon.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstructs the second (uppass) nodal reconstructions. — mpl_first_up_recon","title":"Reconstructs the second (uppass) nodal reconstructions. — mpl_first_up_recon","text":"Reconstructs second-pass nodal sets. normal (-applicable) characters, final pass. function called preorder sequence nodes left, right, ancestral nodes known. function needs fairly high-performance, much checking parameter validity, thus unsafe usage function might caught. calling functions ensure appropriate parameters set use.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_up_recon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstructs the second (uppass) nodal reconstructions. — mpl_first_up_recon","text":"","code":"mpl_first_up_recon(node_id, left_id, right_id, anc_id, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_up_recon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstructs the second (uppass) nodal reconstructions. — mpl_first_up_recon","text":"node_id index node reconstructed. left_id index left descendant. right_id index right descendant. anc_id index immediate ancestor node. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_up_recon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstructs the second (uppass) nodal reconstructions. — mpl_first_up_recon","text":"null value (now).","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_first_up_recon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reconstructs the second (uppass) nodal reconstructions. — mpl_first_up_recon","text":"Thomas Guillerme","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_charac_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the weight of a character in the dataset — mpl_get_charac_weight","title":"Retrieve the weight of a character in the dataset — mpl_get_charac_weight","text":"Gets weights character dataset.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_charac_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the weight of a character in the dataset — mpl_get_charac_weight","text":"","code":"mpl_get_charac_weight(charID, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_charac_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the weight of a character in the dataset — mpl_get_charac_weight","text":"charID Number character (.e. first character number 1) morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_charac_weight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the weight of a character in the dataset — mpl_get_charac_weight","text":"list, detailing (item 1) exact weight character; (item 2) integer approximation used Morphy.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_charac_weight.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Retrieve the weight of a character in the dataset — mpl_get_charac_weight","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_gaphandl.html","id":null,"dir":"Reference","previous_headings":"","what":"Get / set gap handler from a Morphy object. — mpl_get_gaphandl","title":"Get / set gap handler from a Morphy object. — mpl_get_gaphandl","text":"0 = inapplicable; 1 = missing; 2 = extra","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_gaphandl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get / set gap handler from a Morphy object. — mpl_get_gaphandl","text":"","code":"mpl_get_gaphandl(morphyobj)  mpl_set_gaphandl(handl, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_gaphandl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get / set gap handler from a Morphy object. — mpl_get_gaphandl","text":"mpl_get_gaphandl() returns integer corresponding gap handling approach. mpl_set_gaphandl() returns Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_charac.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the number of character (columns) in the dataset. — mpl_get_num_charac","title":"Retrieve the number of character (columns) in the dataset. — mpl_get_num_charac","text":"Retrieves number character (columns) dataset.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_charac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the number of character (columns) in the dataset. — mpl_get_num_charac","text":"","code":"mpl_get_num_charac(morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_charac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the number of character (columns) in the dataset. — mpl_get_num_charac","text":"morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_charac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the number of character (columns) in the dataset. — mpl_get_num_charac","text":"number internal nodes.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_charac.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Retrieve the number of character (columns) in the dataset. — mpl_get_num_charac","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_internal_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets the number of internal nodal reconstruction sets being used by MorphyLib. — mpl_get_num_internal_nodes","title":"Gets the number of internal nodal reconstruction sets being used by MorphyLib. — mpl_get_num_internal_nodes","text":"Gets number internal nodal reconstruction sets used MorphyLib.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_internal_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets the number of internal nodal reconstruction sets being used by MorphyLib. — mpl_get_num_internal_nodes","text":"","code":"mpl_get_num_internal_nodes(morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_internal_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets the number of internal nodal reconstruction sets being used by MorphyLib. — mpl_get_num_internal_nodes","text":"morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_internal_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets the number of internal nodal reconstruction sets being used by MorphyLib. — mpl_get_num_internal_nodes","text":"number internal nodes.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_num_internal_nodes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gets the number of internal nodal reconstruction sets being used by MorphyLib. — mpl_get_num_internal_nodes","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_numtaxa.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the number of taxa (rows) in the dataset. — mpl_get_numtaxa","title":"Retrieve the number of taxa (rows) in the dataset. — mpl_get_numtaxa","text":"Retrieves number taxa (rows) dataset.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_numtaxa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the number of taxa (rows) in the dataset. — mpl_get_numtaxa","text":"","code":"mpl_get_numtaxa(morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_numtaxa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the number of taxa (rows) in the dataset. — mpl_get_numtaxa","text":"morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_numtaxa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the number of taxa (rows) in the dataset. — mpl_get_numtaxa","text":"number taxa success, otherwise error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_numtaxa.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Retrieve the number of taxa (rows) in the dataset. — mpl_get_numtaxa","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_symbols.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieves the current list of symbols. — mpl_get_symbols","title":"Retrieves the current list of symbols. — mpl_get_symbols","text":"Returns pointer string character state symbols currently used Morphy (.e. either list symbols extracted matrix, caller-specified values).","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_symbols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieves the current list of symbols. — mpl_get_symbols","text":"","code":"mpl_get_symbols(morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_symbols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieves the current list of symbols. — mpl_get_symbols","text":"morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_symbols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieves the current list of symbols. — mpl_get_symbols","text":"C-style (null-terminated) string character state symbols used. NULL failure.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_get_symbols.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Retrieves the current list of symbols. — mpl_get_symbols","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_init_Morphy.html","id":null,"dir":"Reference","previous_headings":"","what":"Sets up the dimensions of the dataset. — mpl_init_Morphy","title":"Sets up the dimensions of the dataset. — mpl_init_Morphy","text":"Provides initial dimensions dataset, constrain input matrix supplied Morphy.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_init_Morphy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sets up the dimensions of the dataset. — mpl_init_Morphy","text":"","code":"mpl_init_Morphy(numtaxa, numchars, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_init_Morphy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sets up the dimensions of the dataset. — mpl_init_Morphy","text":"numtaxa number taxa (tips/terminals). numchars number characters (.e. transformation series) data set. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_init_Morphy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sets up the dimensions of the dataset. — mpl_init_Morphy","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_init_Morphy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sets up the dimensions of the dataset. — mpl_init_Morphy","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_new_Morphy.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a new instance of a Morphy object — mpl_new_Morphy","title":"Creates a new instance of a Morphy object — mpl_new_Morphy","text":"Creates new empty Morphy object. fields unpopulated uninitialised.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_new_Morphy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a new instance of a Morphy object — mpl_new_Morphy","text":"","code":"mpl_new_Morphy()"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_new_Morphy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a new instance of a Morphy object — mpl_new_Morphy","text":"void pointer Morphy instance. NULL unsuccessful.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_new_Morphy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Creates a new instance of a Morphy object — mpl_new_Morphy","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_new_Morphy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a new instance of a Morphy object — mpl_new_Morphy","text":"","code":"morphyObj <- mpl_new_Morphy() # Create new object ## Do some stuff ... ## mpl_delete_Morphy(morphyObj) # Delete when done #> [1] 0"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_down_recon.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs the second nodal reconstructions for characters with inapplicability. — mpl_second_down_recon","title":"Performs the second nodal reconstructions for characters with inapplicability. — mpl_second_down_recon","text":"Updates nodal sets ambiguous unions inapplicable state calculates steps involving applicable states update. function needs fairly high-performance, much checking parameter validity, thus unsafe usage function might caught. calling functions ensure appropriate parameters set use.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_down_recon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs the second nodal reconstructions for characters with inapplicability. — mpl_second_down_recon","text":"","code":"mpl_second_down_recon(node_id, left_id, right_id, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_down_recon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs the second nodal reconstructions for characters with inapplicability. — mpl_second_down_recon","text":"node_id index node reconstructed. left_id index left descendant. right_id index right descendant. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_down_recon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs the second nodal reconstructions for characters with inapplicability. — mpl_second_down_recon","text":"integral parsimony length (right now)","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_down_recon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Performs the second nodal reconstructions for characters with inapplicability. — mpl_second_down_recon","text":"Thomas Guillerme","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_up_recon.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalises the ancestral state reconstructions for characters with inapplicable values. — mpl_second_up_recon","title":"Finalises the ancestral state reconstructions for characters with inapplicable values. — mpl_second_up_recon","text":"Finalises nodal sets characters may involved inapplicable token counts excess regions applicability nodes least two descendant subtrees possess applicable characters. function needs fairly high-performance, much checking parameter validity, thus unsafe usage function might caught. calling functions ensure appropriate parameters set use.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_up_recon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalises the ancestral state reconstructions for characters with inapplicable values. — mpl_second_up_recon","text":"","code":"mpl_second_up_recon(node_id, left_id, right_id, anc_id, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_up_recon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finalises the ancestral state reconstructions for characters with inapplicable values. — mpl_second_up_recon","text":"node_id index node reconstructed. left_id index left descendant. right_id index right descendant. anc_id index immediate ancestor node. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_up_recon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finalises the ancestral state reconstructions for characters with inapplicable values. — mpl_second_up_recon","text":"integral parsimony length (right now)","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_second_up_recon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finalises the ancestral state reconstructions for characters with inapplicable values. — mpl_second_up_recon","text":"Thomas Guillerme","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_charac_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the weight of a character in the dataset — mpl_set_charac_weight","title":"Set the weight of a character in the dataset — mpl_set_charac_weight","text":"Sets weight character dataset.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_charac_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the weight of a character in the dataset — mpl_set_charac_weight","text":"","code":"mpl_set_charac_weight(charID, weight, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_charac_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the weight of a character in the dataset — mpl_set_charac_weight","text":"charID Number character (.e. first character number 1) weight Weight assign morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_charac_weight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the weight of a character in the dataset — mpl_set_charac_weight","text":"error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_charac_weight.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Set the weight of a character in the dataset — mpl_set_charac_weight","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_num_internal_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Sets the number of internal nodes in the dataset — mpl_set_num_internal_nodes","title":"Sets the number of internal nodes in the dataset — mpl_set_num_internal_nodes","text":"specifies number internal nodes reconstruction sets need made. caller ensure correct number nodes relationships .","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_num_internal_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sets the number of internal nodes in the dataset — mpl_set_num_internal_nodes","text":"","code":"mpl_set_num_internal_nodes(numnodes, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_num_internal_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sets the number of internal nodes in the dataset — mpl_set_num_internal_nodes","text":"numnodes desired number internal nodes. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_num_internal_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sets the number of internal nodes in the dataset — mpl_set_num_internal_nodes","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_num_internal_nodes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sets the number of internal nodes in the dataset — mpl_set_num_internal_nodes","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_parsim_t.html","id":null,"dir":"Reference","previous_headings":"","what":"Sets a character's parsimony function type — mpl_set_parsim_t","title":"Sets a character's parsimony function type — mpl_set_parsim_t","text":"Set parsimony function type one defined morphydefs.h header file. Setting character type NONE_T also cause excluded calculations.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_parsim_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sets a character's parsimony function type — mpl_set_parsim_t","text":"","code":"mpl_set_parsim_t(char_id, tname = \"typename\", morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_parsim_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sets a character's parsimony function type — mpl_set_parsim_t","text":"char_id number character (transformation series) defined input matrix.  first character numbered 1 (one). tname parsimony function type defined morphydefs.h morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_parsim_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sets a character's parsimony function type — mpl_set_parsim_t","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_set_parsim_t.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sets a character's parsimony function type — mpl_set_parsim_t","text":"Martin Brazeau","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_translate_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts a numeric error code to human-readable format — mpl_translate_error","title":"Converts a numeric error code to human-readable format — mpl_translate_error","text":"Converts numeric error code human-readable format","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_translate_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts a numeric error code to human-readable format — mpl_translate_error","text":"","code":"mpl_translate_error(errorCode)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_translate_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts a numeric error code to human-readable format — mpl_translate_error","text":"errorCode Non-positive integer converted","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_translate_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts a numeric error code to human-readable format — mpl_translate_error","text":"character string corresponding provided error code","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_translate_error.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Converts a numeric error code to human-readable format — mpl_translate_error","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_translate_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts a numeric error code to human-readable format — mpl_translate_error","text":"","code":"mpl_translate_error(-1) # \"ERR_INVALID_SYMBOL\" #> [1] \"ERR_INVALID_SYMBOL\""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_lower_root.html","id":null,"dir":"Reference","previous_headings":"","what":"Updates the nodal sets for a lower (","title":"Updates the nodal sets for a lower (","text":"trees rooted, Morphy uppass functions require lower \"dummy\" root order function properly. function called set nodal state sets dummy root. nodal set equal set root node, unless ambiguous union applicable gap tokens gaps treated applicable. case, set union resolved favour applicable tokens set.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_lower_root.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updates the nodal sets for a lower (","text":"","code":"mpl_update_lower_root(l_root_id, root_id, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_lower_root.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updates the nodal sets for a lower (","text":"l_root_id index lower root. root_id index upper root node. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_lower_root.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updates the nodal sets for a lower (","text":"Morphy error code.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_lower_root.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Updates the nodal sets for a lower (","text":"Thomas Guillerme","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_tip.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial update of tip values following uppass reconstruction. — mpl_update_tip","title":"Initial update of tip values following uppass reconstruction. — mpl_update_tip","text":"Ambiguous terminal state sets need resolved first uppass based descendant state values order local reoptimisation procedures accurate inapplicable step counting proceed accurately. function calls updaters records states active subtrees, thereby allowing second downpass accurately reconstruct subtree state activity. function needs fairly high-performance, much checking parameter validity, thus unsafe usage function might caught. calling functions ensure appropriate parameters set use.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_tip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial update of tip values following uppass reconstruction. — mpl_update_tip","text":"","code":"mpl_update_tip(tip_id, anc_id, morphyobj)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_tip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial update of tip values following uppass reconstruction. — mpl_update_tip","text":"tip_id index tip updated. anc_id index tip's immediate ancestor. morphyobj instance Morphy object.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_tip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initial update of tip values following uppass reconstruction. — mpl_update_tip","text":"integral parsimony length (right now)","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/mpl_update_tip.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Initial update of tip values following uppass reconstruction. — mpl_update_tip","text":"Thomas Guillerme","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/profiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirically counted profiles for small trees — profiles","title":"Empirically counted profiles for small trees — profiles","text":"base 2 logarithm number trees containing s steps, calculated scoring character n-leaf tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/profiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirically counted profiles for small trees — profiles","text":"","code":"profiles"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/profiles.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Empirically counted profiles for small trees — profiles","text":"list structure profiles[[number leaves]][[number tokens]][[tokens smallest split]] list entry returns named numeric vector; entry lists log2(proportion n-leaf trees s fewer steps character).","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/profiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empirically counted profiles for small trees — profiles","text":"","code":"data(profiles)  # Load profile for a character of the structure 0 0 0 1 1 1 1 1 profile3.5 <- profiles[[8]][[2]][[3]]  # Number of trees with _s_ or fewer steps on that character TreeTools::NUnrooted(8) * 2 ^ profile3.5 #>     1     2     3     4  #>   225  2475  8019 10395"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/referenceTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree topology for matrix simulation — referenceTree","title":"Tree topology for matrix simulation — referenceTree","text":"tree topology used generate matrices congreveLamsdellMatrices","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/referenceTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree topology for matrix simulation — referenceTree","text":"","code":"referenceTree"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/referenceTree.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Tree topology for matrix simulation — referenceTree","text":"single phylogenetic tree saved object class phylo","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/referenceTree.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Tree topology for matrix simulation — referenceTree","text":"Congreve & Lamsdell (2016); doi:10.1111/pala.12236","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/referenceTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Tree topology for matrix simulation — referenceTree","text":"Congreve2016TreeSearch Congreve2016ddTreeSearch","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/referenceTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree topology for matrix simulation — referenceTree","text":"","code":"data(referenceTree) plot(referenceTree)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/summary.morphyPtr.html","id":null,"dir":"Reference","previous_headings":"","what":"Details the attributes of a morphy object — summary.morphyPtr","title":"Details the attributes of a morphy object — summary.morphyPtr","text":"Details attributes morphy object","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/summary.morphyPtr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Details the attributes of a morphy object — summary.morphyPtr","text":"","code":"# S3 method for class 'morphyPtr' summary(object, ...)"},{"path":"https://ms609.github.io/TreeSearch/dev/reference/summary.morphyPtr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Details the attributes of a morphy object — summary.morphyPtr","text":"object Morphy object ... parameters...","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/reference/summary.morphyPtr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Details the attributes of a morphy object — summary.morphyPtr","text":"list detailing number taxa, internal nodes, characters weights.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/reference/summary.morphyPtr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Details the attributes of a morphy object — summary.morphyPtr","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-1519006-2025-02","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.1.9006 (2025-02)","title":"TreeSearch 1.5.1.9006 (2025-02)","text":"PlotCharacter() performs ancestral state reconstruction consensus trees #179","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-1519005-2025-02","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.1.9005 (2025-02)","title":"TreeSearch 1.5.1.9005 (2025-02)","text":"Support ordered (additive) characters Require R 4.0 (simplify maintenance)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-1519003-2025-02","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.1.9003 (2025-02)","title":"TreeSearch 1.5.1.9003 (2025-02)","text":"Improve support constraints AdditionTree() #173","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-1519002-2025-01","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.1.9002 (2025-01)","title":"TreeSearch 1.5.1.9002 (2025-01)","text":"Buttons download consensus trees app","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-1519001-2024-12","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.1.9001 (2024-12)","title":"TreeSearch 1.5.1.9001 (2024-12)","text":"Fix SPR behaviour move close root","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-1519000-2024-10","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.1.9000 (2024-10)","title":"TreeSearch 1.5.1.9000 (2024-10)","text":"Fix display state labels app","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-151-2024-05-23","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.1 (2024-05-23)","title":"TreeSearch 1.5.1 (2024-05-23)","text":"CRAN release: 2024-05-23 Fix calls DescendantEdges()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-150-2024-04-03","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.5.0 (2024-04-03)","title":"TreeSearch 1.5.0 (2024-04-03)","text":"CRAN release: 2024-04-03 MaximumLength() calculates maximum possible length characters, including inapplicable tokens Consistency() now returns retention index rescaled consistency index","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-140-2023-08-18","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.4.0 (2023-08-18)","title":"TreeSearch 1.4.0 (2023-08-18)","text":"CRAN release: 2023-08-26","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-1-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 1.4.0 (2023-08-18)","text":"TaxonInfluence() calculates influence individual taxa phylogenetic inference","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"search-improvements-1-4-0","dir":"Changelog","previous_headings":"","what":"Search improvements","title":"TreeSearch 1.4.0 (2023-08-18)","text":"Default use equal weighting ratchet iterations Support null constraints AdditionTree()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"app-improvements-1-4-0","dir":"Changelog","previous_headings":"","what":"App improvements","title":"TreeSearch 1.4.0 (2023-08-18)","text":"Exclude taxa search app Allow search continue loading new file different taxon names app","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"housekeeping-1-4-0","dir":"Changelog","previous_headings":"","what":"Housekeeping","title":"TreeSearch 1.4.0 (2023-08-18)","text":"Update calls DescendantEdges() compatibility ‘TreeTools’ 1.10.0","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-132-2023-04-27","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.3.2 (2023-04-27)","title":"TreeSearch 1.3.2 (2023-04-27)","text":"CRAN release: 2023-04-27 Use PlotTools::SpectrumLegend() continuous scales app Restore auto-termination .t files","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-131-2023-03-29","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.3.1 (2023-03-29)","title":"TreeSearch 1.3.1 (2023-03-29)","text":"CRAN release: 2023-03-29 PlotCharacter() now returns invisibly Fix missing character Wills 2012 dataset Search character text GUI Call C functions using symbols","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-130-2023-02-20","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.3.0 (2023-02-20)","title":"TreeSearch 1.3.0 (2023-02-20)","text":"CRAN release: 2023-02-20","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-1-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 1.3.0 (2023-02-20)","text":"New function LengthAdded() tests characters contribute taxon instability, per Pol & Escapa (2009), doi:10.1111/j.1096-0031.2009.00258.x WhenFirstHit() recovers tree search information tree names New vignette tree space mapping Support phylo trees constraints","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"gui-improvements-1-3-0","dir":"Changelog","previous_headings":"","what":"GUI improvements","title":"TreeSearch 1.3.0 (2023-02-20)","text":"Support reading characters Excel spreadsheets Allow retention suboptimal trees Use K-means++ clustering","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-120-2022-07-35","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.2.0 (2022-07-35)","title":"TreeSearch 1.2.0 (2022-07-35)","text":"CRAN release: 2022-08-10 Export log tree search commands Export R scripts reproduce figures Simplify layout Misc bug fixes New function QuartetResolution() evaluates quartet resolved list trees","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-112-2022-05-11","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.1.2 (2022-05-11)","title":"TreeSearch 1.1.2 (2022-05-11)","text":"CRAN release: 2022-05-11 Check tree order & rootedness scoring (#133) Improve error handling Replace throw stop C++ Remove test elapsed times, CRAN compliance","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-111-2022-03-22","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.1.1 (2022-03-22)","title":"TreeSearch 1.1.1 (2022-03-22)","text":"CRAN release: 2022-03-22 GUI allows selection subset trees, easier analysis Bayesian tree sets Miscellaneous fixes improvements ‘shiny’ GUI Test suite ‘shiny’ GUI Update tests TreeSearch 1.7","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-110-2022-01-17","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.1.0 (2022-01-17)","title":"TreeSearch 1.1.0 (2022-01-17)","text":"CRAN release: 2022-01-17 Improvements ‘shiny’ GUI Better integration rogue taxon exploration New vignette describing profile parsimony MinimumLength() fully supports ambiguous applicability","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-101-2021-09-27","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.0.1 (2021-09-27)","title":"TreeSearch 1.0.1 (2021-09-27)","text":"CRAN release: 2021-09-27 Memory management invalid input Corrections metadata","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-100-2021-09-21","dir":"Changelog","previous_headings":"","what":"TreeSearch 1.0.0 (2021-09-21)","title":"TreeSearch 1.0.0 (2021-09-21)","text":"CRAN release: 2021-09-22","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-functions-1-0-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"TreeSearch 1.0.0 (2021-09-21)","text":"EasyTrees() ‘shiny’ graphical user interface tree search AdditionTree() adds taxon sequence parsimonious place tree, generating parsimonious starting tree neighbour-joining PlotCharacter() reconstructs character distributions trees ConstrainedNJ() constructs starting trees respect constraint ImposeConstraint() reconciles tree constraint SiteConcordance() calculates exact site concordance ConcordantInformation() evaluates signal:noise dataset implied given tree PrepareDataProfile() simplifies dataset allow partial search multiple applicable tokens present Resample() conducts bootstrap jackknife resampling Consistency() calculates consistency retention ‘indices’ MinimumLength() calculates minimum length character dataset tree.","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"improvements-1-0-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"TreeSearch 1.0.0 (2021-09-21)","text":"TreeLength() supports lists trees Set handling ‘gap’ token (-) creating Morphy object gap = Label nodes split frequencies using JackLabels(plot = FALSE) Support topological constraints tree search Remove redundant function AsBinary() Drop nTip parameter RandomTreeScore() (infer morphyObj) C implementations rearrangement functions Improved command line interface search progress messaging","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"deprecations-1-0-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"TreeSearch 1.0.0 (2021-09-21)","text":"Remove redundant internal function LogisticPoints()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-043-2020-07-09","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.4.3 (2020-07-09)","title":"TreeSearch 0.4.3 (2020-07-09)","text":"CRAN release: 2020-07-09 Update tests compatibility ‘TreeTools’ v1.1.0 Improve memory pointer handling","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-042-2020-07-07","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.4.2 (2020-07-07)","title":"TreeSearch 0.4.2 (2020-07-07)","text":"CRAN release: 2020-07-07 Update tests compatibility ‘TreeTools’ v1.1.0","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-041-2020-06-09","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.4.1 (2020-06-09)","title":"TreeSearch 0.4.1 (2020-06-09)","text":"CRAN release: 2020-06-09 Compatibility ‘TreeTools’ v1.0.0","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-040-2020-02-06","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.4.0 (2020-02-06)","title":"TreeSearch 0.4.0 (2020-02-06)","text":"CRAN release: 2020-02-06","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 0.4.0 (2020-02-06)","text":"PhyDatToMatrix(), complementing MatrixToPhyDat() Documentation ‘pkgdown’ JackLabels() helper function","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Changes","title":"TreeSearch 0.4.0 (2020-02-06)","text":"Move tree distance measures new package ‘TreeDist’ Move tree utility functions new package ‘TreeTools’ Rename functions MinimumSteps()→MinimumLength() FitchSteps()→CharacterLength()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"enhancements-0-4-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeSearch 0.4.0 (2020-02-06)","text":"Improve speed tests (increasing probability false positives) Use message place cat, allow use suppressMessages()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-032-2019-06-03","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.3.2 (2019-06-03)","title":"TreeSearch 0.3.2 (2019-06-03)","text":"CRAN release: 2019-06-03 Improve text, content build speed vignettes","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-0-3-1","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 0.3.1","text":"NyeTreeSimilarity() function implements tree similarity metric Nye et al. (2006) MatchingSplitDistance() function implementing Matching Split distance Bogdanowicz & Giaro (2012)","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"bug-fixes-0-3-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"TreeSearch 0.3.1","text":"Check whether input tree bifurcating attempting rearrangements, avoid crashes unsupported input","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-030-2019-03-21","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.3.0 (2019-03-21)","title":"TreeSearch 0.3.0 (2019-03-21)","text":"CRAN release: 2019-03-21","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 0.3.0 (2019-03-21)","text":"Implement information theoretic tree distance measure (Smith, 2020) Prepare new random number generator R3.6.0","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"deprecations-0-3-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"TreeSearch 0.3.0 (2019-03-21)","text":"Function TreeSplits() deprecated; use .Splits() instead","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"bug-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"TreeSearch 0.3.0 (2019-03-21)","text":"Correct mistakes documentation","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-022-2019-01-02","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.2.2 (2019-01-02)","title":"TreeSearch 0.2.2 (2019-01-02)","text":"CRAN release: 2019-01-02 Correct vignette titles","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-021-2018-12-07","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.2.1 (2018-12-07)","title":"TreeSearch 0.2.1 (2018-12-07)","text":"CRAN release: 2018-12-07","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-0-2-1","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 0.2.1 (2018-12-07)","text":"CollapseNodes() CollapseEdges() allow creation polytomies Tree2Splits() lists bipartition splits implied tree topology","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"enhancements-0-2-1","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeSearch 0.2.1 (2018-12-07)","text":"SplitFrequency() now supports larger trees Can specify tip labels directly ReadTntTree(), avoid reliance generative file","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"bug-fixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"TreeSearch 0.2.1 (2018-12-07)","text":"Export missing functions","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-020-2018-09-10","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.2.0 (2018-09-10)","title":"TreeSearch 0.2.0 (2018-09-10)","text":"CRAN release: 2018-09-11","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 0.2.0 (2018-09-10)","text":"RootTree() allows rooting tree incompletely specified single-taxon outgroup AllTBR() returns trees one TBR rearrangement away TBRMoves() reports possible TBR rearrangements Jackknife() conducts Jackknife resampling SplitFrequency() reports frequency clades forest SupportColour() allows visual marking support values ApeTime() reports creation date ape-exported tree SortTree() flips nodes consistent left-right order AsBinary() supports 0","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"enhancements-0-2-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeSearch 0.2.0 (2018-09-10)","text":"[IW]RatchetConsensus() renamed [IW]MultiRatchet(), giving better description function’s purpose Don’t warn missing EOL reading Nexus TNT files Add new 12-colour colourblind-friendly palette FitchSteps() now supports datasets tips found tree Improve portability function ReadTntTree()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"TreeSearch 0.2.0 (2018-09-10)","text":"[IW]MultiRatchet() now considers trees identical even ’ve hit different number times","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-012-2018-03-20","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.1.2 (2018-03-20)","title":"TreeSearch 0.1.2 (2018-03-20)","text":"CRAN release: 2018-03-19 Update MorphyLib library fix C warnings Remove non-ASCII characters data Disable slow-building problematic vignette Use local copy citation style building vignettes","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-010-2018-03-14","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.1.0 (2018-03-14)","title":"TreeSearch 0.1.0 (2018-03-14)","text":"CRAN release: 2018-03-14","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-0-1-0","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 0.1.0 (2018-03-14)","text":"Helper functions read Nexus TNT data trees Brewer palette local data allow easier colouring","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"enhancements-0-1-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeSearch 0.1.0 (2018-03-14)","text":"Allow additional parameters passed consensus() via ConsensusWithout()","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"bug-fixes-0-1-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"TreeSearch 0.1.0 (2018-03-14)","text":"C11 compliance IWRatchetConsensus() now relays concavity value subsequent functions ReadCharacters() returns labels characters states character_num = NULL","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-008","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.0.8","title":"TreeSearch 0.0.8","text":"CRAN release: 2018-03-08","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"new-features-0-0-8","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeSearch 0.0.8","text":"Added NJTree() function shortcut generate Neighbour-Joining tree dataset Add functions allow recovery trees one rearrangement input","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"efficiency-gains-0-0-8","dir":"Changelog","previous_headings":"","what":"Efficiency gains","title":"TreeSearch 0.0.8","text":"Separate NNISwap() functions allow efficient rearrangement edgeLists [9002] Improve efficiency using three-pass algorithm place four-pass precursor [9004] Bootstrap search improvements","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"bug-fixes-0-0-8","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"TreeSearch 0.0.8","text":"[9003] User now able specify value concavity constant (overridden k = 4) [9003] Bootstrap replicates now scored correctly (without warning) implied weights","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"inapplicable-tokens-0-0-7","dir":"Changelog","previous_headings":"","what":"Inapplicable tokens:","title":"TreeSearch 0.0.7","text":"Integrated package (previously inapplicable) Handle inapplicable data via API Martin Brazeau’s Morphy Phylogenetic Library","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"profile-parsimony-0-0-7","dir":"Changelog","previous_headings":"","what":"Profile Parsimony:","title":"TreeSearch 0.0.7","text":"Integrated package (previously ProfileParsimony) Faster calculation concavity profiles C Persistent memoization R.cache","code":""},{"path":"https://ms609.github.io/TreeSearch/dev/news/index.html","id":"treesearch-006","dir":"Changelog","previous_headings":"","what":"TreeSearch 0.0.6","title":"TreeSearch 0.0.6","text":"CRAN release: 2017-11-07 First CRAN submission","code":""}]
