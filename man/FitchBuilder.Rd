% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FitchBuilder.R
\name{FitchBuilder}
\alias{FitchBuilder}
\title{Fitch skeleton builder}
\usage{
FitchBuilder(steps, tokenCount)
}
\arguments{
\item{steps}{Integer; Number of steps to build to}

\item{tokenCount}{Integer vector: Number of leaves displaying each state.

\code{FitchBuilder()} is a first step to computing how many phylogenetic trees, with
leaves labelled unambiguously by character states, exhibit \emph{steps} steps
under Fitch parsimony.

The approach we take inverts the standard Fitch parsimony procedure.

We first generate 'skeleton' trees with \code{FitchBuilder()}.  These trees
comprise only the minimum number of leaves necessary to produce \emph{steps}
steps.
Each leaf in the returned skeletons corresponds to one of the Fitch regions
that must be occupied by at least one observed leaf with a given label.
Once we have a complete set of such leaves, we work out how many
ways there are to add the remaining leaves, \strong{without introducing any more
steps}.

To generate the complete list of skeleton trees, we simply work our way
up from a specified root.  For convenience, as the position of the root
is immaterial to the Fitch parsimony score, we will root our tree next to
the first clade containing solely token 1. This will allow us to compute
the number of unrooted trees with the desired score.

Rooting in this position, there will be no steps incurred on the left subtree.
We will therefore add our first step on the right subtree.
The root of the right subtree must thus be one
of the states that will trigger a step when paired with token \code{1}: perhaps
\code{2} or \verb{[2, 4]}.

Now let's consider that node. We need to consider each unique pair of states
that could yield the observed node label; and we can observe whether it
introduces an additional step.  For each permutation we can move up another
node.  We continue until we've used up all our steps, or we've run out of
tokens.

We will end up generating some skeletons that are impossible, because the
recursive algorithm doesn't know what the right branch is doing whilst it's
traversing the left branch in preorder.  These will get filtered out when it
comes to calculating how many ways each skeleton can be populated with the
observed leaf labels.}
}
\description{
Fitch skeleton builder
}
\examples{
# Number of trees with 2 steps for character 0011122
FitchBuilder(2, c(2, 3, 2)) |> FitchPopulateCount()


}
