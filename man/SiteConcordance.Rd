% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Concordance.R
\name{SiteConcordance}
\alias{SiteConcordance}
\alias{QuartetConcordance}
\alias{ClusteringConcordance}
\alias{PhylogeneticConcordance}
\alias{MutualClusteringConcordance}
\alias{SharedPhylogeneticConcordance}
\title{Concordance factors}
\usage{
QuartetConcordance(tree, dataset = NULL, weight = TRUE, return = "mean")

ClusteringConcordance(tree, dataset, return = "edge", normalize = TRUE)

PhylogeneticConcordance(tree, dataset)

MutualClusteringConcordance(tree, dataset)

SharedPhylogeneticConcordance(tree, dataset)
}
\arguments{
\item{tree}{A tree of class \code{\link[ape:read.tree]{phylo}}.}

\item{dataset}{A phylogenetic data matrix of \pkg{phangorn} class
\code{phyDat}, whose names correspond to the labels of any accompanying tree.
Perhaps load into R using \code{\link[TreeTools]{ReadAsPhyDat}()}.
Additive (ordered) characters can be handled using
\code{\link[TreeTools]{Decompose}()}.}

\item{weight}{Logical specifying whether to weight sites according to the
number of quartets they are decisive for.}

\item{return}{Character specifying what to return.
\itemize{
\item \code{"mean"} returns the mean concordance index at each split across all sites.
\item \code{"all"} returns all values calculated during the working for each site at
each split.
}}

\item{normalize}{Logical or numeric; if \code{TRUE} the mutual information will be
normalized such that zero corresponds to the expected mutual information of
a randomly drawn character with the same distribution of tokens.
If \code{FALSE}, zero will correspond to zero mutual information,
even if this is not achievable in practice.
The exact analytical solution, though fast, does not account for
non-independence between splits. This limitation is minor for larger
trees, and becomes negligible for trees with more than ~200 leaves.
For smaller trees, the expected value for random trees can be approximated
by resampling relabelled trees. Setting \code{normalize = n} will approximate the
expected value based on \emph{n} samples.

For \code{return = "char"}, \code{"tree"}, values will be normalized such that 1
corresponds to the maximum possible value, and 0 to the expected value.
If \code{normalize = TRUE}, this will be the expected value for a random
character on the given tree. If \code{normalize} is numeric, the expected value
will be estimated by fitting the character to \code{n} uniformly random trees.}
}
\value{
\code{ClusteringConcordance(return = "all")} returns a 3D array where each
slice corresponds to a character (site), each column to a tree split, and
each row to a different information measure. The \code{normalized} row gives the
normalized mutual information between each split-character pair, scaled so
that 1.0 corresponds to \code{hBest} (the theoretical maximum mutual information,
being the minimum of \code{hSplit} and \code{hChar}) and 0.0 corresponds to \code{miRand}
(the expected mutual information under random association). \code{hSplit} gives
the entropy (information content) of each split's bipartition; \code{hChar} gives
the entropy of each character's state distribution; \code{hJoint} gives the joint
entropy of the split-character confusion matrix; \code{mi} gives the raw mutual
information; and \code{n} records the number of informative observations.
Negative normalized values indicate observed mutual information below random
expectation. \code{NA} is returned when \code{hBest = 0} (no information potential).

\code{ClusteringConcordance(return = "edge")} returns a vector where each element
corresponds to a split (an edge of the tree) and gives the normalized mutual
information between that split and the character data, averaged across all
characters.
When \code{normalize = TRUE} (default), values are scaled relative to random
expectation; when \code{FALSE}, raw mutual information normalized by \code{hBest} is
returned.

\code{ClusteringConcordance(return = "char")} returns a vector where each element
corresponds to a character (site) and gives the entropy-weighted average
normalized mutual information between that character and all tree splits.
Characters with higher information content receive proportionally more weight
from splits that can potentially convey more information about them.

\code{ClusteringConcordance(return = "tree")} returns a single value representing
the overall concordance between the tree topology and the character data.
This averages the fit of the best-matching split for each character.
This is probably biased. I have not identified a circumstance in which it
produces meaningful results.  Let me know if you find one.

I had previously considered calculating
the entropy-weighted average of normalized mutual
information across all split-character pairs, where each pair contributes
proportionally to its potential information content.
The problem here is that imperfect matches between compatible splits
come to dominate, resulting in a small score that gets smaller as trees get
larger, even with a perfect fit.

\code{MutualClusteringConcordance()} returns the mutual clustering
concordance of each character in \code{dataset} with \code{tree}.
The attribute \code{weighted.mean} gives the mean value, weighted by the
information content of each character.

\code{SharedPhylogeneticConcordance()} returns the shared phylogenetic
concordance of each character in \code{dataset} with \code{tree}.
The attribute \code{weighted.mean} gives the mean value, weighted by the
information content of each character.
}
\description{
Concordance measures the strength of support that characters in a dataset
present for each split (=edge/branch) in a tree
\insertCite{Minh2020;SmithConc}{TreeSearch}.
}
\details{
\code{QuartetConcordance()} is the proportion of quartets (sets of four leaves)
that are decisive for a split which are also concordant with it.
For example, a quartet with the characters \verb{0 0 0 1} is not decisive, as
all relationships between those leaves are equally parsimonious.
But a quartet with characters \verb{0 0 1 1} is decisive, and is concordant
with any tree that groups the first two leaves together to the exclusion
of the second.

By default, the reported value weights each site by the number of quartets
it is decisive for.  This value can be interpreted as the proportion of
all decisive quartets that are concordant with a split.
If \code{weight = FALSE}, the reported value is the mean of the concordance
value for each site.
Consider a split associated with two sites:
one that is concordant with 25\% of 96 decisive quartets, and
a second that is concordant with 75\% of 4 decisive quartets.
If \code{weight = TRUE}, the split concordance will be 24 + 3 / 96 + 4 = 27\%.
If \code{weight = FALSE}, the split concordance will be mean(75\%, 25\%) = 50\%.

\code{QuartetConcordance()} is computed exactly, using all quartets, where as
other implementations (e.g. IQ-TREE) follow
\insertCite{@Minh2020;textual}{TreeSearch} in using a random subsample
of quartets for a faster, if potentially less accurate, computation.
Ambiguous and inapplicable tokens are treated as containing no grouping information
(i.e. \code{(02)} or \code{-} are each treated as \verb{?}).

\code{MutualClusteringConcordance()} treats each character as a tree.
Each token in the character corresponds to a node in the tree whose pendant
edges are the taxa with that token.
The Mutual Clustering Concordance is then the Mutual Clustering Information
\insertCite{Smith2020}{TreeSearch} of the tree thus defined with \code{tree}.

\code{SharedPhylogeneticConcordance()} treats each character as a simple tree.
Each token in the character corresponds to a node whose pendant edges are the
taxa with that token.
The Shared Phylogenetic Concordance for each character in \code{dataset} is then
the Shared Phylogenetic Information \insertCite{Smith2020}{TreeSearch} of
this tree and \code{tree}.
}
\examples{
data("congreveLamsdellMatrices", package = "TreeSearch")
dataset <- congreveLamsdellMatrices[[1]][, 1:20]
tree <- TreeSearch::referenceTree

cc <- ClusteringConcordance(tree, dataset)
mcc <- MutualClusteringConcordance(tree, dataset)

qc <- QuartetConcordance(tree, dataset)

pc <- PhylogeneticConcordance(tree, dataset)
spc <- SharedPhylogeneticConcordance(tree, dataset)

oPar <- par(mar = rep(0, 4), cex = 0.8) # Set plotting parameters
plot(tree)
TreeTools::LabelSplits(tree, signif(qc, 3), cex = 0.8)
plot(tree)
TreeTools::LabelSplits(tree, signif(cc, 3), cex = 0.8)
par(oPar) # Restore plotting parameters

# Write concordance factors to file
labels <- paste0(cc, "/", qc, "/", pc) # "/" is a valid delimiter
# Identify the node that corresponds to each label
whichNode <- match(TreeTools::NTip(tree) + 1:tree$Nnode, names(qc))

# The contents of tree$node.label will be written at each node
tree$node.label <- labels[whichNode]

ape::write.tree(tree) # or write.nexus(tree, file = "mytree.nex")

# Display correlation between concordance factors
pairs(cbind(cc, mcc, qc, pc, spc), asp = 1)
data(congreveLamsdellMatrices)
myMatrix <- congreveLamsdellMatrices[[10]]
ClusteringConcordance(TreeTools::NJTree(myMatrix), myMatrix)
}
\references{
\insertAllCited{}
}
\seealso{
\itemize{
\item \code{\link[=Consistency]{Consistency()}}
}

Other split support functions: 
\code{\link{JackLabels}()},
\code{\link{Jackknife}()},
\code{\link{MaximizeParsimony}()},
\code{\link{MostContradictedFreq}()},
\code{\link{PresCont}()}
}
\author{
\href{https://smithlabdurham.github.io/}{Martin R. Smith}
(\href{mailto:martin.smith@durham.ac.uk}{martin.smith@durham.ac.uk})
}
\concept{split support functions}
