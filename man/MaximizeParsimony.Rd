% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TreeSearch.R
\name{MaximizeParsimony}
\alias{MaximizeParsimony}
\alias{EasyTrees}
\alias{EasyTreesy}
\title{Find most parsimonious trees}
\usage{
MaximizeParsimony(
  dataset,
  tree = NJTree(dataset),
  ratchIter = 12L,
  tbrIter = 6L,
  finalIter = 3L,
  maxHits = 20L,
  concavity = Inf,
  tolerance = sqrt(.Machine$double.eps),
  constraint = NULL,
  verbosity = 2L,
  session = NULL
)

EasyTrees()

EasyTreesy()
}
\arguments{
\item{dataset}{A phylogenetic data matrix of class \code{\link[phangorn]{phyDat}},
whose names correspond to the labels of any accompanying tree.}

\item{tree}{(optional) A bifurcating tree of class \code{\link{phylo}},
containing only the tips listed in \code{dataset}, from which the search
should begin.
If unspecified, a neighbour-joining tree will be generated from \code{dataset}.
Edge lengths are not supported and will be deleted.}

\item{ratchIter}{Numeric specifying number of iterations of the
parsimony ratchet (Nixon 1999) to conduct.}

\item{tbrIter}{Numeric specifying the maximum number of \acronym{TBR}
break points to evaluate before concluding each search.
The counter is reset to zero each time tree score improves.
One 'iteration' comprises breaking a single branch and evaluating all
possible reconnections.}

\item{finalIter}{Numeric: the final round of tree search will evaluate
\code{finalIter} Ã— \code{tbrIter} \acronym{TBR} break points.}

\item{maxHits}{Numeric specifying the maximum times that an optimal
parsimony score may be hit before concluding a ratchet iteration or final
search concluded.}

\item{concavity}{Numeric specifying concavity constant for implied step
weighting; set as \code{Inf} for equal step weights (which is a bad idea; see
Smith 2019).}

\item{tolerance}{Numeric specifying degree of suboptimality to tolerate
before rejecting a tree.  The default, \code{sqrt(.Machine$double.eps)}, retains
trees that may be equally parsimonious but for rounding errors.
Setting to larger values will include trees suboptimal by up to \code{tolerance}
in search results, which may improve the accuracy of the consensus tree
(at the expense of resolution) (Smith 2019).}

\item{constraint}{Either \code{NULL} or an object of class \code{phyDat}. Trees that
are not perfectly compatible with each character in \code{constraint} will not
be considered during search.
See \href{https://ms609.github.io/TreeSearch/articles/inapplicable.html}{vignette}
for further examples.}

\item{verbosity}{Integer specifying level of messaging; higher values give
more detailed commentary on search progress. Set to \code{0} to run silently.}

\item{session}{'shiny' session identifier to allow \code{\link[=setProgress]{setProgress()}} calls
to be sent when \code{MaximizeParsimony()} is called from within a shiny app..}
}
\description{
Search for most parsimonious trees using the parsimony ratchet and
\acronym{TBR} rearrangements, treating inapplicable data as such using the
algorithm of Brazeau, Guillerme & Smith (2019).

Tree search will be conducted from a specified or automatically-generated
starting tree in order to find a tree with an optimal parsimony score,
under implied or equal weights, treating inapplicable characters as such
in order to avoid the artefacts of the standard Fitch algorithm
(see Maddison 1993; Brazeau et al. 2019).
}
\details{
Tree search commences with \code{ratchIter} iterations of the parsimony ratchet
(Nixon 1999), which bootstraps the input dataset in order to escape local
optima.  A final round of tree bisection and reconnection (\acronym{TBR})
is conducted to broaden the sampling of trees.

This function can be called using the R command line / terminal, or through
the 'shiny' graphical user interface app (type \code{EasyTrees()} to launch).

For detailed documentation of the TreeSearch package, including full
instructions for loading phylogenetic data into R and initiating and
configuring tree search, see the
\href{https://ms609.github.io/TreeSearch}{package documentation}.
}
\examples{
library('TreeTools')
data('Lobo', package = 'TreeTools')
dataset <- Lobo.phy

# A very quick run for demonstration purposes
MaximizeParsimony(dataset, ratchIter = 0, tbrIter = 1, concavity = 10,
                  maxHits = 5, verbosity = 4)

# Be sure to check that the score has converged on a global optimum,
# conducting additional iterations and runs as necessary.

\dontrun{ # launches 'shiny' point-and-click interface
  EasyTrees() 
}

# Tree search with a constraint
constraint <- MatrixToPhyDat(c(a = 1, b = 1, c = 0, d = 0, e = 0, f = 0))
characters <- MatrixToPhyDat(matrix(
  c(0, 1, 1, 1, 0, 0,
    1, 1, 1, 0, 0, 0), ncol = 2,
  dimnames = list(letters[1:6], NULL)))
MaximizeParsimony(characters, constraint = constraint, verbosity = 0)

}
\references{
\insertRef{Brazeau2019}{TreeSearch}

\insertRef{Maddison1993}{TreeSearch}

\insertRef{Nixon1999}{TreeSearch}

\insertRef{Smith2019}{TreeSearch}
}
\author{
\href{https://orcid.org/0000-0001-5660-1727}{Martin R. Smith}
(\href{mailto:martin.smith@durham.ac.uk}{martin.smith@durham.ac.uk})
}
