% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NNI.R
\name{cNNI}
\alias{cNNI}
\title{Nearest-neighbour interchange}
\usage{
cNNI(tree, edgeToBreak = NULL, whichSwitch = NULL)
}
\arguments{
\item{tree}{A tree of class \code{\link{phylo}}.}

\item{edgeToBreak}{Integer from zero to \code{nEdge(tree) - nTip(tree) - 2},
specifying which internal edge to break.}

\item{whichSwitch}{Integer from zero to one, specifying which way to re-build
the broken internal edge.}
}
\value{
A tree of class \code{phylo}, rooted on the same leaf,
on which the specified rearrangement has been conducted.
}
\description{
\code{cNNI()} performs a nearest neighbour interchange using C; it is faster than
\code{NNI()}.
}
\details{
\code{cNNI()} expects a binary tree rooted on a single leaf, whose root node
is the lowest numbered internal node.
}
\examples{
tree <- TreeTools::BalancedTree(8)
# A random rearrangement
cNNI(tree)
# Manual random sampling
cNNI(tree, sample.int(14 - 8 - 1, 1), sample.int(2, 1))
# A specified rearrangement
cNNI(tree, 0, 0)

# If a tree may not be binary, collapse nodes with
tree <- TreeTools::MakeTreeBinary(tree)

# If a tree may be improperly rooted, use
tree <- TreeTools::RootTree(tree, 1)

# If a tree may exhibit unusual node ordering, this can be addressed with
tree <- TreeTools::Preorder(tree)
}
\references{
The algorithm is summarized in
\insertRef{Felsenstein2004}{TreeSearch}
}
\author{
\href{https://orcid.org/0000-0001-5660-1727}{Martin R. Smith}
(\href{mailto:martin.smith@durham.ac.uk}{martin.smith@durham.ac.uk})
}
