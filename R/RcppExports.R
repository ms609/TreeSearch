# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Number of leaf labellings producing given tree lengths
#' 
#' @param tree A binary tree of class phylo
#' @param tokens Integer vector: Occurrences of each token
#' @param steps Integer vector: maximum number of steps to compute.
#' A negative value computes all possible step counts.
#' 
#' Given a tree, how many distinct leaf labellings produce a tree length of
#' $k$ under Fitch parsimony?  
#' The number of leaves exhibiting each character state is given by `tokens`.
#' 
#' 
#' @examples
#' tree <- TreeTools::BalancedTree(7)
#' tokens <- c(2, 3, 2) # e.g. 0 0 1 1 1 2 2
#' FixedTreeCount(tree, 2:4, tokens)
#' 
#' Note: setting `Inf` for steps will give all possible outcomes.
#' Setting a lower value will allow some recursions to terminate early,
#' potentially improving runtime - but probably not by much.
#' 
#' @returns `FixedTreeCount()` returns a vector of names `0`...`maxSteps`,
#' where each entry lists the natural logarithm of the number of distinct
#' labellings that produce that Fitch length.
#' 
#' @importFrom TreeTools CladeSizes
#' @export
FixedTreeCount <- function(tree, tokens, steps = -1.0) {
    .Call(`_TreeSearch_FixedTreeCount`, tree, tokens, steps)
}

#' @describeIn FixedTreeCount Process a bunch of characters at once
#' @param tokenMatrix Integer matrix in which each column corresponds to a
#' character.
FixedTreeCountBatch <- function(tree, tokenMatrix, steps = -1.0) {
    .Call(`_TreeSearch_FixedTreeCountBatch`, tree, tokenMatrix, steps)
}

#' @rdname Carter1
#' @examples
#' MaddisonSlatkin(2, c("0" = 2, "1" = 3, "01" = 0, "2" = 2)) * NUnrooted(7)
#' 
#' @export
MaddisonSlatkin <- function(steps, states) {
    .Call(`_TreeSearch_MaddisonSlatkin`, steps, states)
}

#' @export
#' @keywords internal
MaddisonSlatkin_clear_cache <- function() {
    invisible(.Call(`_TreeSearch_MaddisonSlatkin_clear_cache`))
}

#' Exact Distribution of Parsimony Score on a Tree (I.I.D. Model)
#'
#' `active_parsimony_dist()` computes the log-probability that a character generated by independent 
#' resampling of leaf states has a parsimony length L(T) = k.
#'
#' @param tree A phylo object (list with edge matrix).
#' @param state_probs A numeric vector of probabilities for each state (0..r-1).
#'        Must sum to 1. Length determines r.
#' @param steps The maximum cost k to compute (returns 0..k).
#' 
#' @return A named numeric vector of log-probabilities for steps 0 to k.
#' @export
active_parsimony_dist <- function(tree, state_probs, steps) {
    .Call(`_TreeSearch_active_parsimony_dist`, tree, state_probs, steps)
}

#' Expectation and Variance of Parsimony Score
#'
#' `parsimony_moments()` efficiently computes the Expected value (E) and Variance (V) of the parsimony 
#' length L(T) under the I.I.D. model.
#'
#' @rdname active_parsimony_dist
#' @return `parsimony_moments` returns a list with components `expectation` and `variance`.
#' @export
parsimony_moments <- function(tree, state_probs) {
    .Call(`_TreeSearch_parsimony_moments`, tree, state_probs)
}

ClearCarterCache <- function() {
    invisible(.Call(`_TreeSearch_ClearCarterCache`))
}

CarterCacheSize <- function() {
    .Call(`_TreeSearch_CarterCacheSize`)
}

Log2Carter1 <- function(m, a, b) {
    .Call(`_TreeSearch_Log2Carter1`, m, a, b)
}

LogCarter1 <- function(m, a, b) {
    .Call(`_TreeSearch_LogCarter1`, m, a, b)
}

#' Number of trees with _m_ steps
#' 
#' Functions to compute the number of trees with a given parsimony score.
#' 
#' `Carter1()` calculates the number of trees in which Fitch parsimony will
#' reconstruct  \eqn{m} steps, where \eqn{a} leaves are labelled with one state,
#' and \eqn{b} leaves are labelled with a second state, using theorem 1 of
#' \insertCite{Carter1990;textual}{TreeTools}:
#' 
#' \deqn{f_m(a,b) = \dfrac{(m-1)!(2n-3m)(2n-5)!!N(a,m)N(b,m)}{(2n-2m-1)!!}}
#' 
#' where \eqn{f_m(a,b)} is the number of unrooted trees with the specified
#' leaf count; \eqn{n} is the number of leaves; and
#' \eqn{N(n,m) = \dfrac{(2n-m-1)!}{(n-m)!(m-1)!2^{n - m}}} (or \eqn{0} if
#'  \eqn{n<m}): the number of forests of \eqn{m} binary rooted trees with
#'  \eqn{n} leaves.
#' 
#' `MaddisonSlatkin()` generalises this result to characters with multiple
#' steps using the recursive approach of
#' \insertCite{Maddison1991;textual}{TreeSearch}.
#' 
#' @param m,steps Number of steps.
#' @param a,b Number of leaves labelled `0` and `1`.
#' @param states Number of leaves labelled with each possible state.
#' States are presented in binary fashion.  The first entry of the vector
#' corresponds to state `1` (binary `001`),
#' the second to state `2` (binary `010`),
#' and the third to the ambiguous state `01` (binary `011`).
#' 
#' 
#' @seealso [TreeTools::NUnrooted()]: number of unrooted trees with _n_ leaves.
#' @references 
#' \insertAllCited{}
#' 
#' See also:
#' 
#' \insertRef{Steel1993}{TreeSearch}
#' 
#' \insertRef{Steel1995}{TreeSearch}
#' 
#' (\insertRef{Steel1996}{TreeSearch})
#' @importFrom TreeTools LogDoubleFactorial
#' @examples 
#' # The character `0 0 0 1 1 1`
#' Carter1(1, 3, 3) # Exactly one step
#' Carter1(2, 3, 3) # Two steps (one extra step)
#' 
#' # Number of trees that the character can map onto with exactly _m_ steps
#' # if non-parsimonious reconstructions are permitted:
#' cumsum(sapply(1:3, Carter1, 3, 3))
#' 
#' # Three steps allow the character to map onto any of the 105 six-leaf trees.
#' Carter1(3, 3, 3)
#' NUnrooted(3 + 3)
#' 
#' @template MRS
#' @family profile parsimony functions
#' @export
Carter1 <- function(m, a, b) {
    .Call(`_TreeSearch_Carter1`, m, a, b)
}

expected_mi <- function(ni, nj) {
    .Call(`_TreeSearch_expected_mi`, ni, nj)
}

mi_key <- function(ni, nj) {
    .Call(`_TreeSearch_mi_key`, ni, nj)
}

maximum_length <- function(x) {
    .Call(`_TreeSearch_maximum_length`, x)
}

mlci_prepare_tree <- function(edge) {
    .Call(`_TreeSearch_mlci_prepare_tree`, edge)
}

logLik_equal_t_prepared <- function(tip_states, weights, k, tree_prep, Ntip, t) {
    .Call(`_TreeSearch_logLik_equal_t_prepared`, tip_states, weights, k, tree_prep, Ntip, t)
}

mle_t_prepared <- function(tip_states, weights, k, tree_prep, Ntip, lower = 1e-8, upper = 10.0, tol = 1e-6) {
    .Call(`_TreeSearch_mle_t_prepared`, tip_states, weights, k, tree_prep, Ntip, lower, upper, tol)
}

mlci_resample <- function(tree_prep, edge, Ntip, obs_states, best_states, precision = 1e-3, maxResample = 10000L, lower = 1e-8, upper = 10.0, tol = 1e-6) {
    .Call(`_TreeSearch_mlci_resample`, tree_prep, edge, Ntip, obs_states, best_states, precision, maxResample, lower, upper, tol)
}

MLCI_rcpp <- function(edge, tipStates, bestSplitInt, precision = 1e-2, maxResample = 10000L) {
    .Call(`_TreeSearch_MLCI_rcpp`, edge, tipStates, bestSplitInt, precision, maxResample)
}

mlci_make_engine <- function(edge, Ntip, maxK = 10L) {
    .Call(`_TreeSearch_mlci_make_engine`, edge, Ntip, maxK)
}

cpp_engine_logLik <- function(eng_xptr, tip_states, weights, k, t) {
    .Call(`_TreeSearch_cpp_engine_logLik`, eng_xptr, tip_states, weights, k, t)
}

cpp_engine_mle <- function(eng_xptr, tip_states, weights, k, lower = 1e-8, upper = 10.0, tol = 1e-6) {
    .Call(`_TreeSearch_cpp_engine_mle`, eng_xptr, tip_states, weights, k, lower, upper, tol)
}

mlci_resample_engine <- function(eng_xptr, obs_states, best_states, precision = 1e-3, maxResample = 10000L, lower = 1e-8, upper = 10.0, tol = 1e-6) {
    .Call(`_TreeSearch_mlci_resample_engine`, eng_xptr, obs_states, best_states, precision, maxResample, lower, upper, tol)
}

preorder_morphy <- function(edge, MorphyHandl) {
    .Call(`_TreeSearch_preorder_morphy`, edge, MorphyHandl)
}

preorder_morphy_by_char <- function(edge, MorphyHandls) {
    .Call(`_TreeSearch_preorder_morphy_by_char`, edge, MorphyHandls)
}

morphy_iw <- function(edge, MorphyHandls, weight, minScore, sequence, concavity, target) {
    .Call(`_TreeSearch_morphy_iw`, edge, MorphyHandls, weight, minScore, sequence, concavity, target)
}

morphy_profile <- function(edge, MorphyHandls, weight, sequence, profiles, target) {
    .Call(`_TreeSearch_morphy_profile`, edge, MorphyHandls, weight, sequence, profiles, target)
}

quartet_concordance <- function(splits, characters) {
    .Call(`_TreeSearch_quartet_concordance`, splits, characters)
}

nni <- function(edge, randomEdge, whichSwitch) {
    .Call(`_TreeSearch_nni`, edge, randomEdge, whichSwitch)
}

spr_moves <- function(edge) {
    .Call(`_TreeSearch_spr_moves`, edge)
}

spr <- function(edge, move) {
    .Call(`_TreeSearch_spr`, edge, move)
}

tbr <- function(edge, move) {
    .Call(`_TreeSearch_tbr`, edge, move)
}

all_spr <- function(edge, break_order) {
    .Call(`_TreeSearch_all_spr`, edge, break_order)
}

all_tbr <- function(edge, break_order) {
    .Call(`_TreeSearch_all_tbr`, edge, break_order)
}

