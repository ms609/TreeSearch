# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Number of leaf labellings producing given tree lengths
#' 
#' @param tree A binary tree of class phylo
#' @param tokens Integer vector: Occurrences of each token
#' @param steps Integer vector: maximum number of steps to compute.
#' A negative value computes all possible step counts.
#' 
#' Given a tree, how many distinct leaf labellings produce a tree length of
#' $k$ under Fitch parsimony?  
#' The number of leaves exhibiting each character state is given by `tokens`.
#' 
#' 
#' @examples
#' tree <- TreeTools::BalancedTree(7)
#' tokens <- c(2, 3, 2) # e.g. 0 0 1 1 1 2 2
#' FixedTreeCount(tree, 2:4, tokens)
#' 
#' Note: setting `Inf` for steps will give all possible outcomes.
#' Setting a lower value will allow some recursions to terminate early,
#' potentially improving runtime - but probably not by much.
#' 
#' @returns `FixedTreeCount()` returns a vector of names `0`...`maxSteps`,
#' where each entry lists the natural logarithm of the number of distinct
#' labellings that produce that Fitch length.
#' 
#' @importFrom TreeTools CladeSizes
#' @export
FixedTreeCount <- function(tree, tokens, steps = -1.0) {
    .Call(`_TreeSearch_FixedTreeCount`, tree, tokens, steps)
}

#' @rdname Carter1
#' @examples
#' MaddisonSlatkin(2, c("0" = 2, "1" = 3, "01" = 0, "2" = 2)) * NUnrooted(7)
#' 
#' @export
MaddisonSlatkin <- function(steps, states) {
    .Call(`_TreeSearch_MaddisonSlatkin`, steps, states)
}

#' @export
#' @keywords internal
MaddisonSlatkin_clear_cache <- function() {
    invisible(.Call(`_TreeSearch_MaddisonSlatkin_clear_cache`))
}

#' Pre-process a tree for Fixed-Tree Maddison Slatkin
#' 
#' @param edge The edge matrix (1-based, Nedges x 2)
#' @param nTips Number of tips
#' @export
FixedTree_Preprocess <- function(edge, nTips) {
    .Call(`_TreeSearch_FixedTree_Preprocess`, edge, nTips)
}

#' Calculate Log-Number of labelings with score k on a Fixed Tree
#' 
#' @param treePtr External pointer to pre-processed tree
#' @param steps vector of steps
#' @param states vector of states (raw counts)
#' @export
FixedTree_Count <- function(treePtr, steps, states) {
    .Call(`_TreeSearch_FixedTree_Count`, treePtr, steps, states)
}

#' Total Number of Unique Labelings (Log Scale)
#' 
#' @param states Integer vector of counts for each state
#' @export
LogMultinomial <- function(states) {
    .Call(`_TreeSearch_LogMultinomial`, states)
}

#' Exact Distribution of Parsimony Score on a Tree (I.I.D. Model)
#'
#' `active_parsimony_dist()` computes the log-probability that a character generated by independent 
#' resampling of leaf states has a parsimony length L(T) = k.
#'
#' @param tree A phylo object (list with edge matrix).
#' @param state_probs A numeric vector of probabilities for each state (0..r-1).
#'        Must sum to 1. Length determines r.
#' @param steps The maximum cost k to compute (returns 0..k).
#' 
#' @return A named numeric vector of log-probabilities for steps 0 to k.
#' @export
active_parsimony_dist <- function(tree, state_probs, steps) {
    .Call(`_TreeSearch_active_parsimony_dist`, tree, state_probs, steps)
}

#' Expectation and Variance of Parsimony Score
#'
#' `parsimony_moments()` efficiently computes the Expected value (E) and Variance (V) of the parsimony 
#' length L(T) under the I.I.D. model.
#'
#' @rdname active_parsimony_dist
#' @return `parsimony_moments` returns a list with components `expectation` and `variance`.
#' @export
parsimony_moments <- function(tree, state_probs) {
    .Call(`_TreeSearch_parsimony_moments`, tree, state_probs)
}

ClearCarterCache <- function() {
    invisible(.Call(`_TreeSearch_ClearCarterCache`))
}

CarterCacheSize <- function() {
    .Call(`_TreeSearch_CarterCacheSize`)
}

Log2Carter1 <- function(m, a, b) {
    .Call(`_TreeSearch_Log2Carter1`, m, a, b)
}

LogCarter1 <- function(m, a, b) {
    .Call(`_TreeSearch_LogCarter1`, m, a, b)
}

#' Number of trees with _m_ steps
#' 
#' Functions to compute the number of trees with a given parsimony score.
#' 
#' `Carter1()` calculates the number of trees in which Fitch parsimony will
#' reconstruct  _m_ steps, where _a_ leaves are labelled with one state,
#' and _b_ leaves are labelled with a second state, using theorem 1 of
#' \insertCite{Carter1990;textual}{TreeTools}
#' 
#' `MaddisonSlatkin()` generalises this result to characters with multiple
#' steps using the recursive approach of
#' \insertCite{Maddison1991;textual}{TreeSearch}.
#' 
#' @param m,steps Number of steps.
#' @param a,b Number of leaves labelled `0` and `1`.
#' @param states Number of leaves labelled with each possible state.
#' States are presented in binary fashion.  The first entry of the vector
#' corresponds to state `1` (binary `001`),
#' the second to state `2` (binary `010`),
#' and the third to the ambiguous state `01` (binary `011`).
#' 
#' 
#' @seealso [TreeTools::NUnrooted()]: number of unrooted trees with _n_ leaves.
#' @references 
#' \insertAllCited{}
#' 
#' See also:
#' 
#' \insertRef{Steel1993}{TreeSearch}
#' 
#' \insertRef{Steel1995}{TreeSearch}
#' 
#' (\insertRef{Steel1996}{TreeSearch})
#' @importFrom TreeTools LogDoubleFactorial
#' @examples 
#' # The character `0 0 0 1 1 1`
#' Carter1(1, 3, 3) # Exactly one step
#' Carter1(2, 3, 3) # Two steps (one extra step)
#' 
#' # Number of trees that the character can map onto with exactly _m_ steps
#' # if non-parsimonious reconstructions are permitted:
#' cumsum(sapply(1:3, Carter1, 3, 3))
#' 
#' # Three steps allow the character to map onto any of the 105 six-leaf trees.
#' Carter1(3, 3, 3)
#' NUnrooted(3 + 3)
#' 
#' @template MRS
#' @family profile parsimony functions
#' @export
Carter1 <- function(m, a, b) {
    .Call(`_TreeSearch_Carter1`, m, a, b)
}

expected_mi <- function(ni, nj) {
    .Call(`_TreeSearch_expected_mi`, ni, nj)
}

mi_key <- function(ni, nj) {
    .Call(`_TreeSearch_mi_key`, ni, nj)
}

maximum_length <- function(x) {
    .Call(`_TreeSearch_maximum_length`, x)
}

preorder_morphy <- function(edge, MorphyHandl) {
    .Call(`_TreeSearch_preorder_morphy`, edge, MorphyHandl)
}

preorder_morphy_by_char <- function(edge, MorphyHandls) {
    .Call(`_TreeSearch_preorder_morphy_by_char`, edge, MorphyHandls)
}

morphy_iw <- function(edge, MorphyHandls, weight, minScore, sequence, concavity, target) {
    .Call(`_TreeSearch_morphy_iw`, edge, MorphyHandls, weight, minScore, sequence, concavity, target)
}

morphy_profile <- function(edge, MorphyHandls, weight, sequence, profiles, target) {
    .Call(`_TreeSearch_morphy_profile`, edge, MorphyHandls, weight, sequence, profiles, target)
}

nni <- function(edge, randomEdge, whichSwitch) {
    .Call(`_TreeSearch_nni`, edge, randomEdge, whichSwitch)
}

spr_moves <- function(edge) {
    .Call(`_TreeSearch_spr_moves`, edge)
}

spr <- function(edge, move) {
    .Call(`_TreeSearch_spr`, edge, move)
}

tbr <- function(edge, move) {
    .Call(`_TreeSearch_tbr`, edge, move)
}

all_spr <- function(edge, break_order) {
    .Call(`_TreeSearch_all_spr`, edge, break_order)
}

all_tbr <- function(edge, break_order) {
    .Call(`_TreeSearch_all_tbr`, edge, break_order)
}

