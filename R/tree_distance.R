#' Information-based generalized Robinson-Foulds distance between two trees
#'
#' Functions reporting the distances or similarities between pairs of trees,
#' based on information-theoretic concepts.
#' 
#'
#' Each partition in a tree can be viewed either as 
#' - (a) a statement that the 'true' tree is one of those that splits the 
#'   taxa as specified;
#' - (b) a statement that the taxa are subdivided into the two groups specified.
#' 
#' The former concept corresponds to the concept of phylogenetic 
#' information, and views the information content of a pair of partitions
#' as relating to the proportion of phylogenetic trees that are consistent
#' with both partitions, giving rise to the
#' Mutual Arboreal Information similarity measure (`MutualArborealInfo`), and 
#' the complementary Variation of Arboreal Information distance metric
#' (`VariationOfArborealInfo`).
#' 
#' The latter #TODO REWRITE
#' 
#' A tree similarity measure is generated by finding an optimal matching that
#' maximises the total information in common between a partition on one tree
#' and its pair on a second, considering all possible ways to pair partitions 
#' between trees (including leaving a partition unpaired).
#' 
#' The returned tree similarity measures state the amount of information, 
#' in bits, that the partitions in two trees hold in common 
#' when they are optimally matched, following Smith (forthcoming).  
#' The complementary tree distance measures state how much information is 
#' different in the partitions of two trees, under an optimal matching.
#' 
#' ## Normalization
#' 
#' If `normalize = TRUE`, then results will be rescaled from zero to a nominal
#' maximum value, calculated thus:
#' 
#' * `MutualArborealInfo`: The information content of the most informative tree.
#' To scale against the information content of the least informative tree, use
#' `normalize = pmax`.
#' 
#' 
#' @param tree1,tree2 Trees of class `phylo`, with tips labelled identically,
#' or lists of such trees to undergo pairwise comparison.
#' 
#' @param normalize If a numeric value is provided, this will be used as a 
#' maximum value against which to rescale results.
#' If `TRUE`, results will be rescaled against a maximum value calculated from
#' the specified tree sizes and topology, as specified in 'details' below.
#' If `FALSE`, results will not be rescaled.
#' 
#' @param reportMatching Logical specifying whether to return the clade
#' matchings as an attribute of the score.
#'
#' @return If `reportMatching = FALSE`, the functions return a numeric 
#' vector specifying the requested similarities or differences.
#' 
#' If `reportMatching = TRUE`, the functions additionally return details
#' of which clades are matched in the optimal matching.
#'  
#' @examples {
#'   tree1 <- ape::read.tree(text='((((a, b), c), d), (e, (f, (g, h))));')
#'   tree2 <- ape::read.tree(text='(((a, b), (c, d)), ((e, f), (g, h)));')
#'   tree3 <- ape::read.tree(text='((((h, b), c), d), (e, (f, (g, a))));')
#'   
#'   # Best possible score is obtained by matching a tree with itself
#'   VariationOfArborealInfo(tree1, tree1) # 0, by definition
#'   MutualArborealInfo(tree1, tree1)
#'   PartitionInfo(tree1) # Maximum mutual arboreal or partition information
#'   
#'   # Best possible score is a function of tree shape; the partitions within
#'   # balanced trees are more independent and thus contain less information
#'   PartitionInfo(tree2)
#'   
#'   # How similar are two trees?
#'   MutualArborealInfo(tree1, tree2) # Amount of arboreal information in common
#'   VariationOfArborealInfo(tree1, tree2) # Distance measure
#'   VariationOfArborealInfo(tree2, tree1) # The metric is symmetric
#'   
#'   # Are they more similar than two trees of this shape would be by chance?
#'   ExpectedVariation(tree1, tree2, sample=12)['VariationOfArborealInfo', 'Estimate']
#'   
#'   # Every partition in tree1 is contradicted by every partition in tree3
#'   # Non-arboreal matches contain partitioning, but not arboreal, information
#'   MutualArborealInfo(tree1, tree3) # = 0
#'   MutualPartitionInfo(tree1, tree3) # > 0
#'   
#' }
#' 
#' @references {
#'  * \insertRef{SmithDist}{TreeSearch}
#' }
#' 
#' @author Martin R. Smith
#' 
#' @family Tree distance
#' @importFrom clue solve_LSAP
#' @export
MutualArborealInfo <- function (tree1, tree2, normalize = FALSE,
                                reportMatching = FALSE) {
  unnormalized <- CalculateTreeDistance(MutualArborealInfoSplits, tree1, tree2, 
                                        reportMatching=reportMatching)
  
  # Return:
  NormalizeInfo(unnormalized, tree1, tree2, how = normalize,
                InfoInTree = PartitionInfo, Combine = pmin)
}

#' @describeIn MutualArborealInfo Variation of phylogenetic information between two trees
#' @export
VariationOfArborealInfo <- function (tree1, tree2, normalize = FALSE,
                                     reportMatching = FALSE) {
  mai <- MutualArborealInfo(tree1, tree2, normalize = FALSE, reportMatching)
  maxi <- outer(PartitionInfo(tree1), PartitionInfo(tree2), '+')
  ret <- maxi - mai - mai
  ret <- NormalizeInfo(ret, tree1, tree2, infoInBoth = maxi,
                InfoInTree = PartitionInfo, how=normalize)
  ret[ret < 1e-13] <- 0 # In case of floating point inaccuracy
  
  attributes(ret) <- attributes(mai)
  # Return:
  ret
}

#' @describeIn MutualPartitionInfo Variation of partition information between two trees
#' @export
VariationOfPartitionInfo <- function (tree1, tree2, normalize = FALSE,
                                      reportMatching = FALSE) {
  mpi <- MutualPartitionInfo(tree1, tree2, normalize = FALSE, reportMatching)
  
  treesIndependentInfo <- outer(PartitionInfo(tree1), PartitionInfo(tree2), '+')
  ret <- treesIndependentInfo - mpi - mpi
  ret <- NormalizeInfo(ret, tree1, tree2, how = normalize,
                       infoInBoth = treesIndependentInfo,
                       InfoInTree = PartitionInfo, Combine = '+')
  
  ret[ret < 1e-13] <- 0 # In case of floating point inaccuracy
  attributes(ret) <- attributes(mpi)
  # Return:
  ret
}

#' @describeIn MutualClusteringInfo Variation of clustering information between two trees
#' @export
VariationOfClusteringInfo <- function (tree1, tree2, normalize = FALSE,
                                       reportMatching = FALSE) {
  mci <- MutualClusteringInfo(tree1, tree2, normalize = FALSE, reportMatching)
  treesIndependentInfo <- outer(ClusteringInfo(tree1), ClusteringInfo(tree2), '+')
  ret <- treesIndependentInfo - mci - mci
  ret <- NormalizeInfo(ret, tree1, tree2, how = normalize,
                       infoInBoth = treesIndependentInfo,
                       InfoInTree = ClusteringInfo, Combine = '+')
  
  ret[ret < 1e-13] <- 0 # In case of floating point inaccuracy
  attributes(ret) <- attributes(mci)
  # Return:
  ret
}

#' @describeIn MutualPartitionInfo Estimate expected Variation of Information
#' and Mutual Information for a pair of trees of a given topology.
#' @param samples Integer specifying how many samplings to obtain; 
#' accuracy of estimate increases with `sqrt(samples)`.
#' @importFrom stats sd
#' @export
ExpectedVariation <- function (tree1, tree2, samples = 1e+3) {
  info1 <- PartitionInfo(tree1)
  info2 <- PartitionInfo(tree2)
  splits1 <- Tree2Splits(tree1)
  splits2 <- Tree2Splits(tree2)
  tipLabels <- rownames(splits2)
  
  mutualEstimates <- vapply(seq_len(samples), function (x) {
    rownames(splits2) <- sample(tipLabels)
    c(MutualPartitionInfoSplits(splits1, splits2),
      MutualArborealInfoSplits(splits1, splits2))
  }, c(MutualPartitionInfo = 0, MutualArborealInfo = 0))
  
  mut <- cbind(Estimate = rowMeans(mutualEstimates),
               sd = apply(mutualEstimates, 1, sd), n = samples)
  # Return:
  ret <- rbind(mut,
        VariationOfPartitionInfo = c(info1 + info2 - mut[1, 1] - mut[1, 1], mut[1, 2] * 2, samples),
        VariationOfArborealInfo =  c(info1 + info2 - mut[2, 1] - mut[2, 1], mut[2, 2] * 2, samples)
        )
  cbind(Estimate = ret[, 1], 'Std. Err.' = ret[, 'sd'] / sqrt(ret[, 'n']), ret[, 2:3])
  
}

#' Nye et al. (2006) tree comparison
#' 
#' Implements the tree comparison metric of Nye _et al_. (2006).
#' In short, this finds the optimal matching that pairs each branch from
#' one tree with a branch in the second, where matchings are scored according to
#' the size of the largest bipartition that is consistent with both of them,
#' normalized against the Jaccard index.
#' 
#' @inheritParams MutualArborealInfo
#' 
#' @references \insertRef{Nye2006}{TreeSearch}
#' @family Tree distance
#' 
#' @author Martin R. Smith
#' @export
NyeTreeSimilarity <- function (tree1, tree2, normalize = FALSE,
                             reportMatching = FALSE) {
  unnormalized <- CalculateTreeDistance(NyeSplitSimilarity, tree1, tree2, 
                                        normalize, reportMatching)
  
  NormalizeInfo(unnormalized, tree1, tree2, how = normalize,
                InfoInTree = function (tr) tr$Nnode - 2L, Combine = max)
}

#' Mutual Partition Information
#' 
#' #TODO document!
#' 
#' @inheritParams MutualArborealInfo
#' 
#' @references \insertRef{SmithDist}{TreeSearch}
#' @family Tree distance
#' 
#' @author Martin R. Smith
#' @export
MutualPartitionInfo <- function (tree1, tree2, normalize = FALSE, 
                                 reportMatching = FALSE) {
  unnormalized <- CalculateTreeDistance(MutualPartitionInfoSplits, tree1, tree2,
                                        reportMatching)
  
  # Return:
  NormalizeInfo(unnormalized, tree1, tree2, how = normalize,
                InfoInTree = PartitionInfo, Combine = pmin)
}

#' Mutual Clustering Information
#' 
#' This approach sees the information content of a pair of partitions as their 
#' mutual clustering information (Meila 2007, Vinh2010).
#' 
#' @inheritParams MutualArborealInfo
#' 
#' @references \insertRef{Meila2007}{TreeSearch}
#' @references \insertRef{SmithDist}{TreeSearch}
#' @references \insertRef{Vinh2010}{TreeSearch}
#' @family Tree distance
#' 
#' @author Martin R. Smith
#' @export
MutualClusteringInfo <- function (tree1, tree2, normalize = FALSE,
                                  reportMatching = FALSE) {
  unnormalized <- CalculateTreeDistance(MutualClusteringInfoSplits, tree1, tree2,
                                        reportMatching)
  NormalizeInfo(unnormalized, tree1, tree2, ClusteringInfo, 
                how = normalize, Combine = pmin)
}

#' Matching Split Distance
#' 
#' Implements the Matching Split Distance for unrooted binary phylogenetic 
#' trees of Bogdanowicz and Giaro (2012).
#' 
#' @inheritParams MutualArborealInfo
#' 
#' @references \insertRef{Bogdanowicz2012}{TreeSearch}
#' @family Tree distance
#' 
#' @author Martin R. Smith
#' @export
MatchingSplitDistance <- function (tree1, tree2, normalize = FALSE,
                             reportMatching = FALSE) {
  unnormalized <- CalculateTreeDistance(MatchingSplitDistanceSplits, tree1, tree2, 
                        reportMatching)
  
  # Return:
  NormalizeInfo(unnormalized, tree1, tree2, how = normalize,
                InfoInTree = function (X) stop("Please specify a function to generate a normalizing constant"),
                Combine = max)
}

#' @describeIn MutualArborealInfo Takes splits instead of trees
#' @template splits12params
#' @export
MutualArborealInfoSplits <- function (splits1, splits2, normalize = TRUE,
                                      reportMatching = FALSE) {
  
  dimSplits1 <- dim(splits1)
  dimSplits2 <- dim(splits2)
  nTerminals <- dimSplits1[1]
  if (dimSplits2[1] != nTerminals) {
    stop("Split rows must bear identical labels")
  }
  lnUnrootedN <- LnUnrooted.int(nTerminals)
  
  swapSplits <- (dimSplits1[2] > dimSplits2[2])
  if (swapSplits) {
    # solve_LDAP expects splits1 to be no larger than splits2
    tmp <- splits1
    splits1 <- splits2
    splits2 <- tmp
    
    tmp <- dimSplits1
    dimSplits1 <- dimSplits2
    dimSplits2 <- tmp
    
    remove(tmp)
  }
  
  taxonNames1 <- rownames(splits1)
  taxonNames2 <- rownames(splits2)
  
  if (!is.null(taxonNames2)) {
    splits2 <- unname(splits2[taxonNames1, , drop=FALSE])
    splits1 <- unname(splits1) # split2[split1] faster without names
  }
  
  nSplits1 <- dimSplits1[2]
  nSplits2 <- dimSplits2[2]
  if (nSplits1 == 0) return (0)
  inSplit1 <- colSums(splits1)
  inSplit2 <- colSums(splits2)
  notInSplit2 <- nTerminals - inSplit2
  
  OneOverlap <- function(A1, A2) {
    if (A1 == A2) {
      # Return:
      LnRooted.int(A1) + LnRooted.int(nTerminals - A2)
    } else {
      if (A1 < A2) {
        tmp <- A2
        A2 <- A1
        A1 <- tmp
      }
      # Return:
      LnRooted.int(A1) + LnRooted.int(nTerminals - A2) - LnRooted.int(A1 - A2 + 1L) 
    }
  }
  
  pairScores <- matrix((mapply(function(i, j) {
    split1 <- splits1[, i]
    split2 <- splits2[, j]
    
    if (all(oneAndTwo <- split1[split2]) ||
        all(notOneNotTwo <- !split1[!split2])) {
      OneOverlap(inSplit1[i], inSplit2[j])
      
    } else if (all(notOneAndTwo <- !split1[split2]) ||
               all(oneNotTwo <- split1[!split2])) {
      OneOverlap(inSplit1[i], notInSplit2[j])
      
    } else {
      lnUnrootedN
    }
  }, seq_len(nSplits1), rep(seq_len(nSplits2), each=nSplits1)
  ) - lnUnrootedN) / -log(2), nSplits1, nSplits2)
  
  if (nSplits1 == 1) {
    max(pairScores)
  } else {
    optimalMatching <- solve_LSAP(pairScores, TRUE)

    # Return:
    ret <- sum(pairScores[matrix(c(seq_along(optimalMatching), optimalMatching), ncol=2L)])
    if (reportMatching) {
      if (!is.null(taxonNames2)) {
        attr(ret, 'matchedSplits') <- 
        if (swapSplits) {
          ReportMatching(splits2, splits1[, optimalMatching], taxonNames1)
        } else {
          ReportMatching(splits1, splits2[, optimalMatching], taxonNames1)
        }
      }
      attr(ret, 'matching') <- optimalMatching
      attr(ret, 'pairScores') <- pairScores
      ret
    } else {
      ret
    }
  }
}


#' @describeIn MutualArborealInfo Calculate variation of arboreal information from splits
#' @export
VariationOfArborealInfoSplits <- function (splits1, splits2, normalize = TRUE,
                                           reportMatching = FALSE) {
  
  dimSplits1 <- dim(splits1)
  dimSplits2 <- dim(splits2)
  nTerminals <- dimSplits1[1]
  if (dimSplits2[1] != nTerminals) {
    stop("Split rows must bear identical labels")
  }
  lnUnrootedN <- LnUnrooted.int(nTerminals)
  
  swapSplits <- (dimSplits1[2] > dimSplits2[2])
  if (swapSplits) {
    # solve_LDAP expects splits1 to be no larger than splits2
    tmp <- splits1
    splits1 <- splits2
    splits2 <- tmp
    
    tmp <- dimSplits1
    dimSplits1 <- dimSplits2
    dimSplits2 <- tmp
    
    remove(tmp)
  }
  
  taxonNames1 <- rownames(splits1)
  taxonNames2 <- rownames(splits2)
  
  if (!is.null(taxonNames2)) {
    splits2 <- unname(splits2[taxonNames1, , drop=FALSE])
    splits1 <- unname(splits1) # split2[split1] faster without names
  }
  
  nSplits1 <- dimSplits1[2]
  nSplits2 <- dimSplits2[2]
  inSplit1 <- colSums(splits1)
  inSplit2 <- colSums(splits2)
  notInSplit1 <- nTerminals - inSplit1
  notInSplit2 <- nTerminals - inSplit2
  
  logTrees1 <- LnRooted(inSplit1) + LnRooted(notInSplit1)
  logTrees2 <- LnRooted(inSplit2) + LnRooted(notInSplit2)
  
  OneOverlap <- function(A1, A2) {
    if (A1 == A2) {
      # Return:
      LnRooted.int(A1) + LnRooted.int(nTerminals - A2)
    } else {
      if (A1 < A2) {
        tmp <- A2
        A2 <- A1
        A1 <- tmp
      }
      # Return:
      LnRooted.int(A1) + LnRooted.int(nTerminals - A2) - LnRooted.int(A1 - A2 + 1L) 
    }
  }
  
  pairScores <- matrix((mapply(function(i, j) {
    split1 <- splits1[, i]
    split2 <- splits2[, j]
    
    logMutualTrees <- 
      if (all(oneAndTwo <- split1[split2]) ||
          all(notOneNotTwo <- !split1[!split2])) {
        OneOverlap(inSplit1[i], inSplit2[j])
        
      } else if (all(notOneAndTwo <- !split1[split2]) ||
                 all(oneNotTwo <- split1[!split2])) {
        OneOverlap(inSplit1[i], notInSplit2[j])
        
      } else {
        lnUnrootedN
      }
    logTrees1[i] + logTrees2[j] - logMutualTrees - logMutualTrees
  }, seq_len(nSplits1), rep(seq_len(nSplits2), each=nSplits1)
  )) / -log(2), nSplits1, nSplits2)
  
  
  
  if (nSplits1 == 1) {
    min(pairScores)
  } else {
    optimalMatching <- solve_LSAP(pairScores, FALSE)
    
    # Return:
    ret <- sum(pairScores[matrix(c(seq_along(optimalMatching), optimalMatching), ncol=2L)])
    if (reportMatching) {
      if (!is.null(taxonNames2)) {
        attr(ret, 'matchedSplits') <- 
          if (swapSplits) {
            ReportMatching(splits2, splits1[, optimalMatching], taxonNames1)
          } else {
            ReportMatching(splits1, splits2[, optimalMatching], taxonNames1)
          }
      }
      attr(ret, 'matching') <- optimalMatching
      attr(ret, 'pairScores') <- pairScores
      ret
    } else {
      ret
    }
  }
}

#' @describeIn NyeTreeSimilarity Takes splits instead of trees
#' @inheritParams MutualArborealInfoSplits
#' @export
NyeSplitSimilarity <- function (splits1, splits2, normalize = TRUE,
                                reportMatching = FALSE) {
  
  dimSplits1 <- dim(splits1)
  dimSplits2 <- dim(splits2)
  nTerminals <- dimSplits1[1]
  if (dimSplits2[1] != nTerminals) {
    stop("Split rows must bear identical labels")
  }
  
  if (dimSplits1[2] < dimSplits2[2]) {
    tmp <- splits1
    splits1 <- splits2
    splits2 <- tmp
    
    tmp <- dimSplits1
    dimSplits1 <- dimSplits2
    dimSplits2 <- tmp
  }
  
  taxonNames <- rownames(splits1) 
  
  if (!is.null(taxonNames)) {
    splits2 <- unname(splits2[rownames(splits1), , drop=FALSE])
    splits1 <- unname(splits1) # split1[split2] faster without names
  }
  
  nSplits1 <- dimSplits1[2]
  nSplits2 <- dimSplits2[2]
  if (nSplits2 == 0) return (0)
  
  Ars <- function (pir, pjs) {
    sum(pir[pjs]) / sum(pir | pjs)
  }
  
  pairScores <- matrix((mapply(function(i, j) {
    splitI0 <- splits1[, i]
    splitJ0 <- splits2[, j]
    splitI1 <- !splitI0
    splitJ1 <- !splitJ0
    
    max(
      min(Ars(splitI0, splitJ0), Ars(splitI1, splitJ1)),
      min(Ars(splitI0, splitJ1), Ars(splitI1, splitJ0))
    )
    
  }, rep(seq_len(nSplits1), each=nSplits2), seq_len(nSplits2)
  )), nSplits2, nSplits1)
  
  if (nSplits2 == 1) {
    min(pairScores)
  } else {
    optimalMatching <- solve_LSAP(pairScores, TRUE)
    
    # Return:
    ret <- sum(pairScores[matrix(c(seq_along(optimalMatching), optimalMatching), ncol=2L)])
    if (reportMatching) {
      attr(ret, 'matching') <- optimalMatching
      attr(ret, 'pairScores') <- pairScores
      ret
    } else {
      ret
    }
  }
}

#' @describeIn MutualPartitionInfo Takes splits instead of trees
#' @inheritParams MutualArborealInfoSplits
#' @export
MutualPartitionInfoSplits <- function (splits1, splits2, reportMatching = FALSE) {
  
  dimSplits1 <- dim(splits1)
  dimSplits2 <- dim(splits2)
  nTerminals <- dimSplits1[1]
  if (dimSplits2[1] != nTerminals) {
    stop("Split rows must bear identical labels")
  }
  
  swapSplits <- (dimSplits1[2] > dimSplits2[2])
  if (swapSplits) {
    # solve_LDAP expects splits1 to be no larger than splits2
    tmp <- splits1
    splits1 <- splits2
    splits2 <- tmp
    
    tmp <- dimSplits1
    dimSplits1 <- dimSplits2
    dimSplits2 <- tmp
    
    remove(tmp)
  }
  
  taxonNames1 <- rownames(splits1)
  taxonNames2 <- rownames(splits2)
  
  if (!is.null(taxonNames2)) {
    splits2 <- unname(splits2[taxonNames1, , drop=FALSE])
    splits1 <- unname(splits1) # split2[split1] faster without names
  }
  
  nSplits1 <- dimSplits1[2]
  nSplits2 <- dimSplits2[2]
  if (nSplits1 == 0) return (0)
  
  AgreementInfoNats <- function (splitI, agree) {
    inAgreement <- sum(agree)
    n0 <- sum(splitI[agree])
    LnUnrooted.int(inAgreement) - LogTreesMatchingSplit(n0, inAgreement - n0)
  }
  
  pairScores <- matrix((mapply(function(i, j) {
    splitI0 <- splits1[, i]
    splitJ0 <- splits2[, j]
    
    agree1 <- splitI0 == splitJ0
    
    max(AgreementInfoNats(splitI0, agree1),
        AgreementInfoNats(splitI0, !agree1))
    
  }, seq_len(nSplits1), rep(seq_len(nSplits2), each=nSplits1)
  )), nSplits1, nSplits2) / log(2)
  
  if (nSplits1 == 1) {
    min(pairScores)
  } else {
    optimalMatching <- solve_LSAP(pairScores, TRUE)
    
    # Return:
    ret <- sum(pairScores[matrix(c(seq_along(optimalMatching), optimalMatching), ncol=2L)])
    if (reportMatching) {
      attr(ret, 'matching') <- optimalMatching
      attr(ret, 'pairScores') <- pairScores
      ret
    } else {
      ret
    }
  }
}

#' @describeIn MutualPartitionInfo Takes splits instead of trees
#' @inheritParams MutualArborealInfoSplits
#' @export
MutualClusteringInfoSplits <- function (splits1, splits2, normalize = TRUE,
                                        reportMatching = FALSE) {
  
  
  dimSplits1 <- dim(splits1)
  dimSplits2 <- dim(splits2)
  nTerminals <- dimSplits1[1]
  if (dimSplits2[1] != nTerminals) {
    stop("Split rows must bear identical labels")
  }
  
  swapSplits <- (dimSplits1[2] > dimSplits2[2])
  if (swapSplits) {
    # solve_LDAP expects splits1 to be no larger than splits2
    tmp <- splits1
    splits1 <- splits2
    splits2 <- tmp
    
    tmp <- dimSplits1
    dimSplits1 <- dimSplits2
    dimSplits2 <- tmp
    
    remove(tmp)
  }
  
  taxonNames1 <- rownames(splits1)
  taxonNames2 <- rownames(splits2)
  
  if (!is.null(taxonNames2)) {
    splits2 <- unname(splits2[taxonNames1, , drop=FALSE])
    splits1 <- unname(splits1) # split2[split1] faster without names
  }
  
  nSplits1 <- dimSplits1[2]
  nSplits2 <- dimSplits2[2]
  if (nSplits1 == 0) return (0)
  
  
  pairScores <- matrix((mapply(function(i, j) {
    MeilaMutualInformation(splits1[, i], splits2[, j])
  }, seq_len(nSplits1), rep(seq_len(nSplits2), each=nSplits1)
  )), nSplits1, nSplits2) / log(2)
  
  if (nSplits1 == 1) {
    min(pairScores)
  } else {
    optimalMatching <- solve_LSAP(pairScores, TRUE)
    
    # Return:
    ret <- sum(pairScores[matrix(c(seq_along(optimalMatching), optimalMatching), ncol=2L)])
    if (reportMatching) {
      attr(ret, 'matching') <- optimalMatching
      attr(ret, 'pairScores') <- pairScores
      ret
    } else {
      ret
    }
  }
}

#' @describeIn MatchingSplitDistance Takes splits instead of trees
#' @inheritParams MutualArborealInfoSplits
#' @importFrom clue solve_LSAP
#' @export
MatchingSplitDistanceSplits <- function (splits1, splits2, normalize = TRUE, 
                                         reportMatching = FALSE) {
  
  dimSplits1 <- dim(splits1)
  dimSplits2 <- dim(splits2)
  nTerminals <- dimSplits1[1]
  if (dimSplits2[1] != nTerminals) {
    stop("Split rows must bear identical labels")
  }
  
  swapSplits <- (dimSplits1[2] > dimSplits2[2])
  if (swapSplits) {
    # solve_LDAP expects splits1 to be no larger than splits2
    tmp <- splits1
    splits1 <- splits2
    splits2 <- tmp
    
    tmp <- dimSplits1
    dimSplits1 <- dimSplits2
    dimSplits2 <- tmp
    
    remove(tmp)
  }
  
  taxonNames1 <- rownames(splits1)
  taxonNames2 <- rownames(splits2)
  
  if (!is.null(taxonNames2)) {
    splits2 <- unname(splits2[taxonNames1, , drop=FALSE])
    splits1 <- unname(splits1) # split2[split1] faster without names
  }
  
  nSplits1 <- dimSplits1[2]
  nSplits2 <- dimSplits2[2]
  if (nSplits1 == 0) return (0)
  
  SymmetricDifference <- function (A, B) {
    (A & !B) | (!A & B)
    #TODO: Assert: These will always be the same size
    #Therefore: Improve efficiency by only calculating one, and not dividing by 2
  }
  
  pairScores <- matrix((mapply(function(i, j) {
    A1 <- splits1[, i]
    A2 <- splits2[, j]
    B1 <- !A1
    B2 <- !A2
    
    min(
      sum(SymmetricDifference(A1, A2), SymmetricDifference(B1, B2)),
      sum(SymmetricDifference(A1, B2), SymmetricDifference(B1, A2))
    ) / 2L
      
  },  seq_len(nSplits1), rep(seq_len(nSplits2), each=nSplits1)
  )), nSplits1, nSplits2)
  
  if (nSplits1 == 1) {
    min(pairScores)
  } else {
    optimalMatching <- solve_LSAP(pairScores, FALSE)
    
    # Return:
    ret <- sum(pairScores[matrix(c(seq_along(optimalMatching), optimalMatching), ncol=2L)])
    if (reportMatching) {
      attr(ret, 'matching') <- optimalMatching
      attr(ret, 'pairScores') <- pairScores
      ret
    } else {
      ret
    }
  }
}

#' Are splits compatible?
#' 
#' Splits are compatible if they are concave; i.e. they can both be true
#' simultaneously.
#' 
#' @template split12Params
#' @return `SplitsCompatible` returns a logical specifying whether the splits
#' provided are compatible with one another.
#' 
#' @author Martin R. Smith
#' @export
SplitsCompatible <- function (split1, split2) {
  # Return:
  (
    all (split1[split2]) ||
    all(split1[!split2]) ||
    all(!split1[split2]) ||
    all(!split1[!split2])
  )
}

#' Visualise a matching
#' 
#' Depicts the bipartitions that are matched between two trees using a 
#' specified Generalized Robinson Foulds tree distance measure.
#' 
#' @param Func Function used to construct tree similarity.
#' @param tree1,tree2 Trees of class `phylo`, with tips labelled identically.
#' @param setPar Logical specifying whether graphical parameters should be 
#' set to display trees side by side.
#' @param Plot Function to use to plot trees.
#' @param \dots Additional parameters to send to `Plot`.
#' 
#' @author Martin R. Smith
#' @importFrom ape nodelabels edgelabels plot.phylo
#' @importFrom colorspace qualitative_hcl
#' @importFrom graphics par
#' @export
VisualizeMatching <- function(Func, tree1, tree2, setPar = TRUE, 
                              Plot = plot.phylo, ...) {
  
  splits1 <- Tree2Splits(tree1)
  edge1 <- tree1$edge
  child1 <- edge1[, 2]
  partitionEdges1 <- vapply(colnames(splits1), 
                            function (node) which(child1 == node), integer(1))
  
  splits2 <- Tree2Splits(tree2)
  edge2 <- tree2$edge
  child2 <- edge2[, 2]
  partitionEdges2 <- vapply(colnames(splits2), 
                            function (node) which(child2 == node), integer(1))
  
  matching <- Func(tree1, tree2, reportMatching = TRUE)
  pairings <- attr(matching, 'matching')
  scores <- attr(matching, 'pairScores')
  pairScores <- signif(mapply(function (i, j) scores[i, j], seq_along(pairings), pairings), 3)
  
  nSplits <- length(pairings)
  palette <- qualitative_hcl(nSplits, c=42, l=88)
  adjNo <- c(0.5, -0.2)
  adjVal <- c(0.5, 1.1)
  
  if (setPar) origPar <- par(mfrow=c(2, 1), mar=rep(0.5, 4))
  
  Plot(tree1)#, ...)
  edgelabels(seq_along(pairings), partitionEdges1[pairings], bg=palette, adj=adjNo)
  #edgelabels(seq_along(pairings), partitionEdges1, cex=0.8, font=2, frame='n', adj=adjVal)
  edgelabels(pairScores, partitionEdges1[pairings], frame='n', adj=adjVal, cex=0.8)
  
  Plot(tree2)#, ...)
  edgelabels(seq_along(pairings), partitionEdges2, bg=palette, adj=adjNo)
  #edgelabels(seq_along(pairings), partitionEdges2, cex=0.8, font=2, frame='n', adj=adjVal)
  edgelabels(pairScores, partitionEdges2, frame='n', adj=adjVal, cex=0.8)
  
  if (setPar) par(origPar)
}