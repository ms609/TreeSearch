---
title: "Tree Search with Custom Optimality Criteria"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Tree Search with Custom Optimality Criteria}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Using Custom Optimality Criteria

'TreeSearch' can be used to search for trees that are optimal under 
user-specified criteria [e.g. @Hopkins2021].

All that is needed is to provide a function that will return a score for a
given tree (and dataset).

First we'll load the necessary R libraries:

```{r init, message = FALSE}
library("TreeTools")
library("TreeSearch", quietly = TRUE, warn.conflict = FALSE)
```

## Maximizing tree balance

We'll start with a very simple case: aiming to minimise the 
total cophenetic index [TIC; @Mir2013] of a tree. 
The TCI is a measure of tree balance; it does not depend on an input dataset.
All we need to do is to write a `TreeScorer` function.  
This function will be sent the `parent` and `child` nodes for each edge in a
tree, and a (here, empty) `dataset` parameter.  The function should return
a score to be minimized.  
Here, we can use a copy of our starting tree as a template, to be populated
with the rearranged `parent` and `child` vectors:

```{r tci-setup}
tree <- PectinateTree(8)
plot(tree)

TCIScore <- function(parent, child, dataset) {
  tree$edge <- cbind(parent, child)
  TotalCopheneticIndex(tree)
}

TCIScore(tree$edge[, 1], tree$edge[, 2], NA)
```

Now we can use our scorer for tree search.
We need to initialize some parameters to `TreeSearch()` with null values:
`dataset = EmptyPhyDat(tree)` sends a blank dataset (as our tree scorer doesn't
require any data); we set `InitializeData = DoNothing` and
`CleanUpData = DoNothing` because we don't need to do anything to `dataset`
before it is sent to `TreeScorer()`.

```{r tci-search}
result <- TreeSearch(tree, dataset = EmptyPhyDat(tree),
                     InitializeData = DoNothing, CleanUpData = DoNothing,
                     TreeScorer = TCIScore,
                     maxIter = 50L, maxHits = 10L, 
                     verbosity = 1L)

plot(result)
```
## Maximizing tree distance

Let's make things slightly more complex, and try to find the tree that is 
most different from a starting tree.  Notice that `TreeSearch` aims to 
_minimize_ the output of `TreeScorer()`, so we negate the tree _distance_ 
(which we aim to maximize) before returning it

```{r tci-setup}
startTree <- BalancedTree(8)
plot(startTree)

DistanceScore <- function(parent, child, dataset) {
  tmpTree <- startTree
  tmpTree$edge <- cbind(parent, child)
  distance <- TreeDist::ClusteringInfoDistance(startTree, tmpTree)
  # Return:
  -distance
}

result <- TreeSearch(RandomTree(8, root = TRUE), dataset = EmptyPhyDat(tree),
                     InitializeData = DoNothing, CleanUpData = DoNothing,
                     TreeScorer = DistanceScore,
                     maxIter = 50L, maxHits = 10L, 
                     verbosity = 1L)

plot(result)
```



## Searching using implied weights

Now we consider a more complex case in which a scorer
must undergo a time-consuming initialization before tree search can begin,
and must be safely destroyed once tree search has completed. 



(Note that implied weights tree search can be conducted much more efficiently
using `MaximizeParsimony(concavity = k)`).

## References